SRM 555 Div2 Easy XorBoardDivTwo
[問題]
  N*Mの'0','1'で構成された数字のグリッドがある。任意の行を一度反転し、その後、任意の列を一度反転する事ができる。
  '1'の数を最大化せよ。
  N, M <= 50

[解答]
  行を全探索しつつ、列も全探索する。逐次反転処理をして、更に二重ループで'1'の数を数える。O(N^2 M^2)

SRM 555 Div2 Med CuttingBitString
[問題]
  '0', '1'で構成された文字列Sが与えられる。これをK個に分割する。分割後の各文字列は2進数表記で必ず5の累乗である必要がある。
  Kの値を最小化せよ。
  |S| <= 50
  
[解答]
  50文字以内の5の累乗を全列挙しておいて、dp[i] := i文字目までの文字列で分割が最小
  dp[i] = min(dp[i], dp[j] + 1)　if substr(j, i-j)が5の累乗
  dp[0] = 0
  dp[i] = inf                    otherwise
  
  5の累乗の文字列生成は
  for(...)
    five *= 5
    temp = five
    string str
    while(temp > 0)
      str += temp % 2 + '0'
      temp /= 2
      ...
    reverse str
  というように行う。
  
SRM 555 Div2 Hard MuddyRoad2
[問題]
  Nマスの列がある。0番目とN-1番目を除いたN-2個のマスのうち、M個のマスが沼であり、その他は乾いた道である。
  一度の移動に+1マスまたは+2マス移動できる。ぬかるんでいるマスには停まることは出来ない。
  0番目からはじめて、N-1番目に到達するための移動の方法の数が偶数通りであったという。
  そのような移動が可能な沼の配置の方法の数を答えよ。(MOD 555,555,555)
  2 <= N <= 555
  0 <= M <= N-2
  
[解答]
  まず沼がない場合の移動の方法の数は、以下のように容易く考えられる。
  現在のマスに到達する方法の数は、直前のマスと2マス前のマスに到達する方法の数の和であるので、
    f[i] = f[i-2] + f[i-1]
  となる。これはフィボナッチ数列である。
  
  次に、問題のジャンプの方法についてより深く考えていく。
  最大でも一度に2マスしか移動できないので、沼が配置されている場合でも移動が可能な場合は、必ず連続する沼の数が一つである。
  沼の状態が以下の様な場合を考えよう。
    _ _ _ x _ _ _ x ...
    0 1 2 3 4 5 6 7 ...
  という場合、3マス目の沼を飛び越えるためには、2マス目に到達していて、2マスジャンプで4マス目に到達するしかない。
  連続する乾いた道に着目すると、その丁度左端から丁度右端に到達する必要がある。
  上の例で考えると、全体の移動の方法の数は (0から2への移動の方法の数) * (4から6への移動の方法の数) * ...
  と表せることが分かる。言い換えると、各々の連続する乾いた道に関して、方法の数を独立に計算することができる。
  さて、全体の移動の方法の数が偶数となるためには、連続する乾いた道のうち、少なくとも1つの移動の方法の数が偶数であれば良い。
  余事象を考えると、全体の移動の方法の数が奇数となるためには、全ての連続する乾いた道の移動の方法の数が奇数である必要がある。
  
  ここで、先に考えておいた沼がない場合の移動の方法の数、即ち連続する乾いた道の移動の方法の数が役立つ。
  連続する乾いた道について、移動の方法の数が奇数であるような長さを持つものを対象とすれば良い。
  よって、フィボナッチ数列をMOD2で計算し、これを連続する乾いた道の幅に対しての方法の数の偶奇とすればよい。
  これが奇数となる道の幅のみを考慮して、Nマスにそのような道を置く方法の数を考えるようなDPをすればよい。
  全体の沼の配置の方法は、comb(N-2, M)であるので、余事象を取れば解となる。
  DPの計算であるが、乾いた道の左端から右端に移動するイメージで記述すると0番目やN-1番目の境界条件で混乱しがちである。
  今回、連続する沼の数がたった1個であることに着目すれば、沼から沼にジャンプして到達する方法の数を数える方が単純に記述できる。
  その場合、-1番目からN番目まで移動する方法の数とし、-1番目とN番目に既に沼があると考え、経路の途中で使える沼の数をちょうどM個とすると良い。
  
  因みにフィボナッチ数について、奇数の場合を計算せずとも「奇奇偶奇奇偶…」というようなMOD3の周期性があるので、それを利用してもよい。

SRM 556 Div2 Easy ChocolateBar
[問題]
  左右から文字を削除し、文字の重複をなくした文字列を作りたい。最大の長さは？
  1<=|S|<=50
  
[解答]
  1. 全部分文字列で重複なし最大を見つける
  2. とぼけて思いつかない人はメモ化再帰する

SRM 556 Div2 Med XorTravelingSalesman
[問題]
  無向グラフと各頂点のコストC[i]が与えられる。頂点0からC[0]で出発して、各頂点のC[i]を現在のコストにXORすることを繰り返す。
  任意のタイミングで停止できるとき、コストを最大化せよ。
  V <= 50
  0 <= C[i] <= 1023

[解答]
  vis[頂点][コスト] としBFSしつくして、最大のコストを求める。状態数 = 50*1024
  
SRM 556 Div2 Hard LeftRightDigitsGame
[問題]
  数字で構成された文字列Sを左から取って並べる。既に数字が並んでいる時、最も左または最も右に追加できる。
  新たにできた数字でLeading0を禁止した時、数字の値が最小であるものを答えよ。
  
[解答]
  基本は、並んでいる数字の0番目より追加する数字のほうが小さいなら左に追加し、そうでないなら右に追加する。deque<char>などで処理するとよい。
  Leading0を禁止しているので、0を除いた最小値の数を数えておいて、まだその値が残っているなら左に0を詰める。もう残っていないなら右に0を詰めるようにする。
  
SRM 557 Div2 Easy GreatFairyWar
[問題]
  複数の敵を順に倒す。敵の攻撃力とHPの配列が与えられる。敵は1ターンに各々が攻撃してくるが、自分は1体に1のダメージしか与えられない。
  全員倒すために受けるダメージの量は？

[解答]
  Σ 攻撃力[i] * (HP[i] + それまでの敵の累積HP) で求まる。

SRM 557 Div2 Med IncubatorEasy
[問題]
  N人のうち、magical[i] = true, protected[i] = false となる人間を最大化したい。
  はじめは magical[i] = protected[i] = false である。protected[i] = false であれば、人iを magical[i] = true にすることが出来る。
  magical[i] = true のとき、love[i][j] = true である全ての人について、protected[j] = true となる。
  また、protected[i] = trueであるとき、love[i][j] = true を満たす全ての人について、protected[j] = true となる。
  1<=N<=10
  
[解答]
  magical[i] = true にしようとする順番をN!通り試し、条件を満たす最大数を答える。
  love[i][j] = true && protected[j] = false である人間について、DFSで protected[j] = true としていく。

SRM 557 Div2 Hard FoxAndMountain
[問題]
  高さが h[0] = h[n] = 0 である山脈があり、h[0]からh[n]まで進む。山脈の連続する一部の進行を示す'U', 'D'で構成される文字列historyが与えられる。
  山脈の高さが0未満となることがないように、山脈のパターン数をmod10^9+9で求めよ。
  n <= 50

[解答]
  やりがちなミスはhistoryの前後のパターン数を掛けたものを足し合わせる方法である。
  これはhistoryのパターンの移動を重複して数えることになるので間違いとなる。
  
  automaton[i]['U'か'D'か] := x=iからの遷移が'U', 'D'であるとき、遷移先のx座標
    automaton[i][j]   = i+1  if history[i] == "DU"[j]
    automaton[i][j^1] = maxJ if history.substr(0, maxJ) == (history.substr(0, i) + "DU"[up^1]).substr(i-maxJ+1)
  
  dp[x=i][historyの先頭j文字が一致した][高さ] := 組み合わせの数
    dp[i+1][automaton[j][0]][k-1] += dp[i][j][k]  if k > 0
    dp[i+1][automaton[j][1]][k+1] += dp[i][j][k]  if k < 25
  
  dp[n][L][0] が答え。mod 10^9+9 を忘れないこと。

SRM 558 Div2 Easy SurroundingGameEasy
[問題]
  N*MのグリッドGがある。Gの各マスは'o', '.'であり、各マスにおいて少なくとも以下の内1つの条件を満たせばB[i][j]点獲得できる。
    - 'o'である
    - 辺を共有するマスが全て'o'である（側面や角を考慮すると、マスは高々4つ）
  また、各マスについて'o'が配置されている場合、コストC[i][j]だけ点が減少する。
  総点数を求めよ。
  N, M <= 20
  
[解答]
  各マスについて、'o'のとき、res += B[i][j] - C[i][j]
  そうでないなら辺を共有するマスを調べて全てが'o'であるなら、res += B[i][j]
  
SRM 558 Div2 Med 

SRM 558 Div2 Hard CatAndRabbit
[問題]
  '.'と'#'で構成される文字列Sがある。'#'を見つけて、そこから'.'のある方向に任意回数移動し、足跡を'#'で塗りつぶす。
  二人でこのゲームをして、はじめに動けなくなった方が負けである。最適な行動をとった時、勝つのは先手か後手か？
  
[解答]
  連続する'.'の数を石の数とみなしたNimである。
  ただし例外的に、Sが全て'.'で構成される場合は、初めから動けないので後手の勝ちである。
  
SRM 559 Div2 Easy BlockTower
[問題]
  与えられる数列の部分列の和を最大化せよ。ただし部分列について、項が奇数となる後は偶数は取れない。
  
[解答]
  1. dp[i番目][最後にとった値が奇数か偶数か] := 和の最大値
  2. 1度奇数をとると後は奇数しか取れなくなるので、奇数を取り出す位置を全探索する。
  
SRM 559 Div2 Med HyperKnight
[問題]

[解答]

SRM 559 Div2 Hard ToyTrain
[問題]
  N*Mのグリッドにレールを敷く。
  レールは'A'(curved, positive edge), 'B'(curved, negative edge), 'S'(straight, positive and negative edge) で構成される。
  グリッドにアルファベットが記されている場合は、それを必ず利用する。記されていない場合は、'S'を配置することが出来る。
  '.'は配置コストはかからないが、['0', '9']はその数だけ配置コストがかかる。一度あるコストxを支払えば、
  同じコストを持つ全ての数字マスは二度以上支払わずに済む。
  全てのレールを完成させた時、総コストを最小化せよ。
  
[解答]
  レールの配置方法は一意に定まる（探索の必要はない）。各行について、'A'が来たら次に必ず'B'が来てレールを閉じる。
  逆に'B'が来たら次に'A'が来てレールを閉じる。各行レールは偶数個である。列についても同様に調べる。
  1つのレールの'A', 'B'の間のvisitedを記録しておいて、行と列のレールの交差がないかを確認する。
  総コストは、全てのレールの生成に必要なコストの和を求めるだけで良い。

SRM 560 Div2 Easy TypingDistance
[問題]
  ２つの文字のタイピング距離が指定された一列のキーボード配列の文字列上の間隔に一致する。
  入力したい文字列を順に処理するとき、タイピング距離の総和を最小化せよ。
  
[解答]
  順に見ていき、abs(position of S[i-1] - position of S[i])の総和を求める。

SRM 560 Div2 Med TomekPhone
[問題]
  複数のキーがあり、各々のキーの割り当てられる文字の数が決まっている。一つのキーに複数個の文字を割り当てるとき、
  k個目の割当の文字を入力したい場合はk回押す必要がある。使用する文字が使用回数の配列で与えられ、全て入力したい時、キーを押す回数の最小値を求めよ。
  1 <= |frequencies|, |keySizes| <= 50
  1 <= frequencies[i] <= 1000

[解答]
  frequencies[i]の大きいものから、割り当てた数の少ないものに貪欲で割り振る。
  frequencies[]を降順ソートして、(キーiの使用回数(1〜), i)ペアをpriority_queueに入れて順に掛けて足し込むなどで解ける。
  
SRM 560 Div2 Hard DrawingPointsDivTwo
[問題]
  格子点上に複数の点を置く。マスの頂点の全てに点が存在する部分において、そのマスの中央に新たな点を描く操作をする。
  その際、元々置いてあった頂点はすべて消す。これを複数回繰り返した結果がN*Mグリッドで'.'（何もない）または'*'(点)で与えられる。
  入力のようなグリッドになるまでに操作を行ってきた回数の最大値を求めよ。ただし、無限に大きくなる場合は-1を示せ。
  
[解答]
  グリッドの'*'の位置を(x, y)とした時、ひとつ前のグリッドには(x-1, y-1), (x, y-1), (x-1, y), (x, y)に'*'が存在したと考えて、
  適当な回数分元に戻すシミュレートをする。その後は、戻したグリッドを復元していくグリッド作りつつ、k回目の復元グリッドとk回目の戻すグリッドを比較して最大値を調べていく。
  無限に戻るかの判定は30くらい戻せば十分確かめられる。

SRM 561 Div2 Easy FoxAndVacation
[問題]
  N個の街があり、それぞれには滞在期間d[i]が与えられる。total日の休暇が割り当てられている。
  できるだけ多くの街を訪れるときの訪れることが出来る街の数の最大値を求めよ。
  
[解答]
  滞在期間を昇順ソートして、小さい順にtotalを消費していく。
  
SRM 561 Div2 Med ICPCBalloons
[問題]
  balloonCount[i]は、i番目の色iのバルーンの数である。各種のサイズは'M'または'L'であり、baloonSize[i]がi番目のバルーンのサイズである。
  問題ごとにバルーンの色とサイズは統一されてなければならない。各問題iにおいて正答数maxAccepted[i]が示される。バルーンの色を変更して正答数の要件を満たすには、
  最小でいくつのバルーンの色を変えればよいか。また、バルーンのサイズは変更できない。
  1 <= |balloonCount| = |balloonSize| <= 50
  1 <= |maxAccepted| <= 15
  
[解答]
  balloonCount[]をサイズごとに分類して、それぞれbl_m[], bl_l[]に詰める。
  問題ごとにどちらのサイズに割り当てるかを全探索(2^15)し、それぞれの割当ごと正答数を2つの配列ac_m[], ac_l[]に分類して詰める。
  bl_m[], bl_l[] と ac_m[], ac_l[]について、降順ソートしてサイズごとそれぞれ比較し差分の和を求め、その最小値を求めれば良い。
  また、サイズごとバルーンの数が足りない場合は、そのサイズ割当は不適となる。

SRM 561 Div2 Hard FoxAndTouristFamilies
[問題]
  木となる無向グラフが与えられる。M世帯あり、それぞれ頂点f[i]に住んでいる。f[i]の値は重複しうる。
  全ての世帯が一度に別のランダムな場所に移動するとき、全世帯が通る辺の数の期待値を求めよ。
  1 <= N <= 51

[解答]
  全世帯が通る辺の数の期待値は、ある1本の辺を全世帯が通る期待値（＝確率）の和である（期待値の線形性）。
  世帯fが辺eを通過するとは、eの端点とfとの距離が遠い方の側に属する任意の点に移動することである。
  fからみて、各頂点がWarshallFloyed等で算出した距離を用いて辺eのどちら側かを判定し、その数countを用いて、
  確率(辺1本とした期待値) = Π count / (V-1) を求める。
  (expected number) = Σ prob (for all edges) が最終的な答え。

SRM 562 Div2 Easy CucumberMarket
[問題]
  N種類のきゅうりが各々price[i]で売られている。任意のK種類を1つずつ選んで購入した時、budget内に収まるか？

[解答]
  price[]を降順ソートしてK個分の和を取りbudgetと比較する。

SRM 562 Div2 Med PastingPaintingDivTwo
[問題]
  白黒のボードの絵を描く。N*Mのクリップボードが与えられる。
  クリップボードの内容をボード左上からx座標とy座標をそれぞれ+1した右下に向けてT回ペーストする。
  出来上がったボードに描かれている黒のマスの数を答えよ。
  1 <= N, M <= 50
  1 <= T <= 10^9

[解答]
  max(N, M)の分だけ、右下にペーストを繰り返す。
  その際の黒のマスの数を基準とし、max(N, M)+1番目のペーストに対する黒マスの増分をT-max(N, M)倍したものを加えればよい。

SRM 562 Div2 Hard RandomOption
[問題]
  badLane1[i]とbadLane2[i]が隣接するとゲームをクリアできない。RandomOptionによってN個のレーンのランダムなpermutationが得られる。
  これを適用してゲームがクリアできるようになる確率を求めよ。
  5 <= keyCount <= 14, 1 <= |badLane1|, |badLane2| <= 50
  0 <= badLane1[i], badLane2[i] <= keyCount-1

[解答]
  dp[使用したキーの集合][最後に使用した右端のキー] := クリアする確率
  dp[used][i] = (Σ dp[used|(1<<j)][j]) / 残りのキーの数  if キーが残っている
  dp[used][i] = 1.0 if キーを使いきった(used == (1<<K)-1)
  メモ化再帰してもよい  

SRM 563 Div2 Easy FoxAndHandleEasy
[問題]
  SをExpandした文字列集合にTが含まれるか？
  Expandとは、Sの先頭と末尾以外の任意の位置に、同じSを挿入した文字列集合を生成することである。
  N <= 50
  
[解答]
  for i in 0..<N
    if T == S.substr(0, i) + S + S.substr(i) then return "Yes"
  return "No"

SRM 563 Div2 Med CoinsGameEasy
[問題]
  N*Mグリッドが与えられる。各マスは'o'(stone),'.'(empty),'#'(wall)で構成される。'o'は2つだけ存在し、
  グリッドを上下左右に傾けることで同じ方向に進行する。壁の場合は進行せず、場外の場合は石がグリッドからはじき出される。
  丁度1個の石が場外にでるための最小操作回数？不可能or操作回数が11回以上なら-1
  N, M <= 50
  
[解答]
  DFSあるいはBFSなどで同時に処理する。
  
SRM 563 Div2 Hard SpellCardsEasy
[問題]
  N枚のカードが有る。
  あるカードiを使用するためには、そのカードとその右側に残っているカードlevel[i]-1枚消費する必要がある。
  カードiを使用するとdamage[i]が与えられる。任意の順序でカードを使用できるとき、与えられるダメージの総量を最大化せよ。
  1 <= N <= 50, 1 <= damage[i] <= 10000

[解答]
  任意の順序でカードを使用できる。どのような順序で使用していくべきか。
  まず、カード0から右方向に使用していくことを考えてみる。
  この方法だと、カードiを使用するとき、右側のどのカードを消費すべきかを判断しなければならない。
  その状態を持つために2^N個の容量が必要となるが、N<=50のためこれは不可。
  よってカード0から右方向に取るか取らないかを選択する方法はあまり良くなさそうである。

  次に、カードN-1から左方向に使用していくことを考えてみる。
  使用するカードの右側のカードをlevel[i]-1枚消費することから、カード0〜i-1を使用するかどうかの情報は、
  カードiを使用するかどうかに影響を与えないので、この方法が良さそうである。

  解法はDPを用いる。状態はひとまず(i番目, 右側のカードの枚数に関する情報j)が良さそうである。
  右側の残り枚数に対して解の値の関数が凸性を持つようなことはないので、貪欲などではなく探索をまとめ上げるDPを用いることを念のため確認しておく。
  
  さて、右からカードを使用するかどうかを決めるということは、再帰の手順に従うと左からバックトラックするようにしてメモ化再帰するのが良い。
  このとき「カードiを使用するということは、カードi+1以降に現在の状態に加えてlevel[i]-1枚のカードの消費責任を負わせる」と解釈することができる。
  よって、状態を(カードi, カードi以降のカードの消費責任j)としてメモ化再帰をし、ダメージ量を最大化すれば良い。
  カードを全て見たときに消費責任j>0であれば、そのようなカードの使用の方法は不適なので-infを返すようにすると良い。
  
SRM 564 Div2 Easy FauxPalindromes
[問題]
  文字列Sが与えられる。Sを以下の3パターンに分類せよ。
  "PALINDROME": 回文
  "FAUX": 隣接文字が同じである場合、それを一文字にまとめたとき回文である文字列
  "NOT EVEN FAUX": 回文でも、FAUXでもない
  
[解答]
  先ず、O(N)の回文判定をする。次に、S.erase(unique(S.begin(), S.end()), S.end())して、回文判定する。

SRM 564 Div2 Med 
[問題]
  R, G, B それぞれのボールの個数が与えられている。左から順にK個使用する。
  使おうとしたボールが0個である場合は、その色を無視して次の色を使用する。最後に使用するボールの色は？
  1 <= R, G, B <= 10^12, 1 <= K <= R+G+B

[解答]
  丁寧に場合分けをする。まだコードを書いていない場合分けの部分を return "x"; するなどして、カスタムケースで確認しながらやると良い。
  はじめに R, G, B の最小数 * 3 < K かで場合分けをする。これを満たす場合、最小数を各々の色から引く。
  残り1色か2色かを判定して、2色である場合は1色になるまで最小数を引いいて同様に場合分けをする。

SRM 564 Div2 Hard KnightCircuit
[問題]
  移動距離が一般化されたチェスのナイトがある。すなわち、x方向の移動距離の絶対値が正の整数a, y方向の絶対値は正の整数b(a≠b)であり、
  各々符号を考慮して8パターンの移動が可能である。これを(a,b)-ナイトという。
  N*Mのグリッドにおいて、任意のマス一つからはじめて(a,b)-ナイトが到達可能なマスの個数を出力せよ。はじめにいるマスもカウントする。
  1 <= N, M <= 10^5
  1 <= a, b <= 10, a and b will not be equal.
  
[解答]
  

SRM 565 Div2 Easy ValueHistogram
[問題]
  N要素の整数配列からヒストグラム(string[])を作成せよ。高さはヒストグラムの要素の最大数+1で、幅は10固定である。
  1 <= N <= 50

[解答]
  H = maxHistogramSize+1, W = 10
  string[] ret(H, string(W, '.'))
  for i in 0..<H for j in 0..<W if hist[j] > i then ret[H-1-i][j] = 'X'

SRM 565 Div2 Med MonstersValley2
[問題]
  順に敵に遭遇する。現在の脅威値が遭遇した敵の脅威値D[i]を下回るなら、敵をC[i]で買収する。
  そうでない場合は、買収するかスルーするかを選ぶことが出来る。
  すべての敵を倒すまでに支払う総コストを最小化せよ。
  N <= 20
  1 <= D[i] <= 2*10^9
  1 <= C[i] <= 2
  
[解答]
  O(N * 2^N)で買収する敵を全探索し、敵との遭遇をシミュレートする。
  脅威値の和は32bit整数に収まらないことに注意する。
  for S in 0..<(1<<N) // 買収する敵を全探索
    for i in 0..<N
      脅威値を計算して条件に適合するなら最小値を算出

SRM 565 Div2 Hard DivisibleSequence
[問題]
  整数列A[]がdivisible sequenceであるとは、0<=i<=N-1において、A[i]がA[i+1]によって割り切れる数列であることを意味する。
  長さHの数列A[]があり、A[0] = Nであるとき、A[]のdivisible sequenceの総数を求めよ。(mod 10^9+9)
  1 <= N, H <= 10^9
  
[解答]
  組み合わせ問題の定石的かつ常識的な考え方として、「『残りがある』は『1個付け足して完全に振り分ける』とみなす」方法がある。
  よって、数列の要素数をN+1個に拡張し、A[H] = 1 と決める。
  すると、Nの各素因数を A[1]〜A[H] に振り分ける問題となる。
  まず写像12相を考える。各素因数について、その字数cをH+1個の箱に配分するので、
  区別できないボールc個を区別できる箱H+1個に配分する問題で、これは仕切りで考える重複組合せとなる。
  すなわち、Nを素因数分解したとき、各素因数iの次数をc[i]とおくと、Π comb(H+c[i]-1, c[i]) (for 全ての素因数i)
  Hが巨大なので、組み合わせの計算にはmod_combを採用する。mod_combではmod_inverse(逆元)を使用する。
  mod_inverseは通常、extgcd(拡張ユーグリッド互除法)を用いて計算する。
  しかし、modが素数の時はフェルマーの小定理により、a^(p-1) ≡ 1 (mod p) i.e. a^(-1) ≡ a^(p-2) (mod p)
  となることから、MOD-2を次数とする繰り返し二乗法で逆元を求めることが出来る。

SRM 566 Div2 Easy PenguinTiles
[問題]
  N*Mグリッドが与えられる。各マスは'P'または'.'で構成される。'.'は空きスペースでグリッド上にただ一つある。
  '.'のある方向に、上下左右で一方向に連続する'P'を一度に移動させることが出来る。操作回数の最小値を答えよ。
  1 <= N, M <= 50

[解答]
  if   i == N-1 && j == M-1:  return 0
  elif i == N-1 || j == M-1:  return 1
  else                        return 2

SRM 566 Div2 Med
[問題]
  赤と青のペンギンを円形に並べた情報が文字列Sで与えられる。Sは'R','B'のいずれかの文字で構成される。
  同じ色を持つペンギンはペアにしてつなげることが出来る。ただし、つなげた線分はどれも交差してはならない。
  つなげられるペアの数を最大化せよ。
  1 <= N <= 50

[解答]
  DFS(L, R) として、範囲DPする。
  Lからiにつなげるとしたループと、Lは使わずにDFS(L+1, R)を求める２つのパターンの再帰を適用する。O(N^3)

SRM 566 Div2 Hard FencingPenguinsEasy
[問題]
  円周上に並んだnumPosts個の杭の幾つかを使って、(x_i, y_i)にいるN匹のペンギンをロープで囲む事を考える。
  杭は(radius, 0)に一つあり円周上を等間隔に並んでいる。
  全てのペンギンを囲むのに必要な、フェンスの囲いの最小面積を求めよ。
  3 <= numPosts <= 222
  5 <= radius <= 100000
  1 <= N <= 50
  
[解答]
  まだACは出ていません。サンプルは通るし凡その方針は間違っていないような気がするけれど…。
  単純なミスや誤差の発生しなさそうなコードに変更したほうが良さそう(放置) 
  
SRM 567 Div2 Easy NinjaTurtles
[問題]
  4匹の亀がいる。亀たちはN体の敵を倒したら、亀のうち3匹はfloor(N/K)個のピザを食べて、1匹はfloor(N/3)個のピザを食べる決まりである。
  ピザの数PとKが与えられる時、Nを求めよ。そのようなNがない場合は-1
  1 <= P <= 10^6
  4 <= K <= 100
  
[解答]
  Nを適当に巨大な数まで全探索すれば良い。実際、N <= 3 * 10^6 程度まで探索すれば十分。
  
SRM 567 Div2 Med TheSquareRootDilemma
[問題]
  正整数A, B(1 <= A <= N, 1 <= B <= M) について、SSR(A, B)が整数となる(A, B)の数を求めよ。
  SSR(x, y) = (sqrt(x) + sqrt(y))^2 で定義される。
  1 <= N, M <= 77777

[解答]
  value = (real_integer: x, imag_integer: y) という形式で無理数を記憶できるタプルvalueを考える。
  [1, 77777]の値をそれぞれ素因数分解し、それぞれの数字nに対してvalue[n]を作成する。
  各素因数の次数の偶奇で、その素因数の無理数を持つかどうかが決まる。各々の素因数の係数は、素因数^(次数の数/2)となる。
  O(max(N, M) * sqrt(max(N, M)))
  
  [1, N]の範囲で、value[i]が整数であるものの数numOfInteger(for N)と無理数kを持つ数numOfIrrational[K](for N)を求める。
  同様に[1, M]の範囲でも求め、双方を掛け合わせたものが答えとなる。
  
SRM 567 Div2 Hard MountainsEasy
[問題]
  N*Mのグリッドは、'X', '.'で構成されていて、'X'は山の一部を示す。グリッドには複数の山が配置されている。
  山はその頂上の座標から一番下の行までまで正三角形をなすように配置される。山の重なりを認めてK個の山が配置される。
  i番目の山の頂上の座標ををS[i]とするとき、数列S[]の組み合わせの数を MOD 10^9+9 で答えよ。
  同じ頂点の組み合わせでも、数列の順番が異なる場合は別の組み合わせとみなすことに注意せよ。
  また、グリッドを生成する山の配置の組み合わせが少なくとも一通りは存在することが保証されている。
  1 <= N, M, K <= 50

[解答]
  グリッド上で明らかに山の頂上となる座標の数Aと、そうでない座標の数Bを数える。
  Aは0行目に存在する'X'の数と、'X'のある座標(x, y)として(x-1, y-1), (x, y-1), (x+1, y-1) が全て'.'である(x, y)座標の数の和である。
  Bは、全ての'X'の数をU(const)と置くと、U-Aに一致する。
  求める解は、A箇所を各々1度以上選択できて、B箇所を各々0個以上選択できる条件のもと、全体でK箇所選択する、という重複順列の拡張のような組み合わせの数である。
  選ぶ山の数に制限がなければ、i番目の山についてB箇所の選び方があるのでB^Kというように重複順列の公式で組み合わせの数を求めることができるが、
  この問題では、A箇所は1回以上選択する必要があるという条件が付いていることを考慮する必要がある。
  では、(Aの式) + B^Kなどとして、AとBは個別に考えられないだろうか。これは、AとBの関係が独立ではなく、U = A + B (const) であるので不可能である。
  言い換えると「一度A箇所ある座標のうち1つの座標を選ぶと、Aの数(1回以上選ぶ必要がある座標の数)は1だけ減少するが、Bの数(0回以上選ぶ必要がある座標の数)は1だけ上昇する。」
  という関係が存在する。よって、以下の様なDPの式を考える。
  C(A, B, K) := A箇所は各々1回以上、B箇所は各々0回以上、全部でK回選ぶ時の組み合わせの総数
  A, Bの関係と、重複順列のような問題の性質を考慮して、次のような漸化式を考えることができる。
  C(A, B, K) = A * C(A - 1, B + 1, K - 1) + B * C(A, B, K - 1)
  「i番目の山の頂上を選ぶ場合の数は、A個ある1つ以上選ぶ必要なる座標のうちのどれかを選ぶ場合と、B個ある0個以上選ぶ必要のある座標のうちからどれかを選ぶ場合の和である」
  という風に漸化式を読むことができる。
  状態の引数が3つあるため、50 * 2500 * 50 の計算量に思えるが、U = A + B (const) より、BはAの補数であるため、状態数の少ないAのみを記憶すれば良い。
  よって、50 * 50 の計算量で十分であることが分かる。漸化式も以下のように簡略化することができる。
  C(A, K) = A * C(A - 1, K - 1) + (U - A) * C(A, K - 1)
  また、50 * 2500 * 50 の計算量ならば、メモした所でギリギリTLEを回避できるのではないかと思われるが、
  コンビネーション計算で既に2500^2個の記憶領域が必要であることから、補数に着目しないとMLEしてしまう。
  
SRM 568 Div2 Easy TheSimilarNumbers
[問題]
  lower 以上 upper 以下の整数集合で、要素が互いに similar でないものの最大要素数を答えよ。
  整数A, B が similar であるとは、B <= A*10 または A <= B*10 であることをいう。
  1 <= lower <= upper <= 1000000
  
[解答]
  lower から upper まで値の全探索をして、最後に使用した値を記憶しつつ10倍超えたら新たに使用出来るようにする。
  使用した回数が答え。

SRM 568 Div2 Med BallsSeparating
[問題]
  R, G, BのボールがN個の箱に割り振られている。それぞれの箱はそれぞれの色に対して、r[i], g[i], b[i]個のボールを含む。
  箱のなかに異なる色が存在しないようにボールを1つずつ移し替える作業の最小回数を求めよ。不可能なら-1を示せ。
  1 <= N <= 50
  1 <= r[i], g[i], b[i] <= 10^6

[解答]
  基本方針は各々の箱から数の少ない色2種類を取り除いていく回数をカウントする。
  しかしこの場合、どの箱にも残らない色の種類が生じる場合があるので、R, G, Bを入れる箱を3つだけ全探索するとして、
  他の箱は基本方針通りに処理すれば良い。
  
SRM 568 Div2 Hard ShuffleSort
[問題]
  各々数字が書かれたN枚のカードがある。数字は重複することがある。
  はじめにこれら全てのカードを手札として、以下の操作を繰り返すことでカードをソートする。
    1.  手札からランダムな順列を作る。
    2.  手札の最も左のカードが、手札のカードのうちの最小の値であれば、それを場に置く。
        この操作を、最も左のカードが最小でなくなるまで繰り返した後、1に戻る。
  全てのカードがソートされて場に置かれるまでに必要な操作回数の期待値を求めよ。
  1 <= N <= 50
  1 <= C[i] <= 50
  
[解答]
  動的計画法は計算結果を状態に対してまとめ上げて計算する全探索である。
  本問において、どのような状態にまとめるのが良いだろうか。
  毎回手札のpermutationをとっているので、カードの順序を状態として保存する必要は無い。
  よってカードを昇順にソートした状態を代表として考えて、そのカードに1, 2の操作をして次の状態へと遷移させることができる。
  具体的に考えよう。N=4, C[]={2,3,1,1}が与えられているものとし、手札のカードの枚数をn枚として表す。
    n = 4のとき、カードの状態は{1,1,2,3}
    n = 3のとき、カードの状態は{1,2,3}
    n = 2のとき、カードの状態は{2,3}
    n = 1のとき、カードの状態は{3}
  これより、昇順ソートしたものを代表としてみなすことで、カードの状態と枚数が一対一対応していること分かる。
  つまり、状態は枚数nだけで計算をまとめあげる事ができるだろうと予測できる。
    dp[n] := 残り枚数がn枚であるときの操作回数の期待値
    
  更に問題の考察を深めたい。問題文を別の表現に言い換えられないだろうか。問題の主な部分を分解しよう。
  そもそも、この問題を混乱させる原因は「手札中の最小値が左に連続する場合は繰り返し手札から取り除く」という2番目の操作にある。
  2番目の操作に対して、1番目の操作は順列を作るのみで条件による行動の分岐が存在しない。
  一度、2番目の操作を除いて考えてみよう。
  1番目の操作は、操作回数を増やすたびにのみ、必ずはじめに行う操作である。
  つまり「操作を行うたびに操作回数を1だけ上昇させる」という仕組みを見いだすことができる。
  この操作追加条件として2番目の操作を与える。
  すると、「操作直後に左のカードが最小値であるという条件をみたしている場合『操作回数の上昇を1回分ごまかす』ことができる」と捉え直すことができる。
  以上より、改めて操作1,2を言い換えると「順列を作るたびに操作回数を1だけ上昇させる。また、順列を作ったときに最小値が左にある場合は操作回数を1回分無視して計算することができる」となる。
  
  ここで、期待値の計算について振り返る。
  まず、期待値は、E(X) = Σ 確率変数i * その確率i によって計算することができる。
  回数の期待値を再帰計算で行う方法は「状態next_iのときの回数(期待値) + 1 が、状態currに対する確率変数iに対応する」ことを用いて、
    E(curr) = Σ (dfs(next_i) + 1) * currからnext_iに遷移する確率
  と計算することができる。
  
  本問の場合、状態n枚に対する期待値は
    「操作回数の上昇をサボって枚数を1だけ減らして、状態n-1枚に遷移する」ものと、
    「操作回数を1だけ上昇させて、状態n枚のまま変化させずに遷移する」ものとの、期待値の和で計算することができる。
  また、それぞれが生じる確率は「最小値の枚数 / n」と「(n - 最小値の枚数) / n」である。
  
  従って、手札n枚に対し手札のうちの最小値の枚数をt枚とすると、以下の式を構成できる。
    dp[n] = Σ {dp(次の遷移できる枚数next[i]) + (next[i]に対する操作回数の調整)} * その確率i
          = dp[n-1]*t/n + (dp[n]+1)*(n-t)/n
  これを変形して、
    dp[n] = dp[n-1] + (n - t) / t
          [t を t[0], t[1], ... と置き換えて]
          = (n - t[n]) / t[n] + (n - 1 - t[n-1]) / t[n-1] + ...
	      = Σ{0<=i<n} (n - i - t[n-i]) / t[n-i] (if n > 0)
            1 (if n = 0)
  式変形より、事前に同じ値の数t[]を数えておけば、単なるループで和を取れば解の期待値が求まることが分かる。
  
SRM 569 Div2 Easy TheJediTestDiv2
[問題]
  ヨーダは最大Y人、ジェダイは1あたり最大J人の生徒を指導できる。
  Nクラスあり各々の生徒人数が与えられるので、指導が行き届くためにはヨーダの指導以外にジェダイを何人起用する必要があるか求めよ。
  1 <= J < Y <= 1000
  1 <= N <= 50
  
[解答]
  ヨーダが指導に当たるクラスを全探索して、ジェダイの最小起用数を求める。
  
SRM 569 Div2 Med TheDeviceDiv2
[問題]
  各々M文字であるN個の文字列 plates: [String] を持っている。各文字列はビットを表している。
  plates[i]とplates[j](i≠j)をデバイスに与えると、対応するk番目のビットplates[i][k], plates[j][k]それぞれに対して、
  AND, OR, XOR のいずれかを行った結果が出力される。platesを全て駆使して、各ビットで行われる演算を識別することが出来るか？
  1 <= N, M <= 50

[解答]
  0 AND 0 = 0  0 OR 0 = 0  0 XOR 0 = 0
  0 AND 1 = 0  0 OR 1 = 1  0 XOR 1 = 1
  1 AND 0 = 0  1 OR 0 = 1  1 XOR 0 = 1
  1 AND 1 = 1  1 OR 1 = 1  1 XOR 1 = 0
  
  0が1つ、1が1つで、ANDと{OR, XOR}の識別ができる。
         1が2つで、{AND, OR}とXORの識別ができる。
  従って、全てのビットkについて0が1つ以上、1が2つ以上あれば全ての演算の識別ができる。
  
SRM 569 Div2 Hard MegaFactorialDiv2
[問題]
  以下の定義で与えられる演算 n!k を考える。
  1) n!k = n!(k-1) * (n-1)!k for n > 0 and k > 0
  2) n!k = 1 for n = 0
  3) n!k = n for k = 0
  
  N!Kの約数の数を求めよ。
  1 <= N <= 1000
  1 <= K <= 100
  
[解答]
  整数nの約数の数は、nを素因数分解したとき、各素因数を0個以上使う組み合わせの数に一致する。つまり Π (各素因数の次数+1) で求めることができる。
  定義に従ってメモ化再帰し、各々の場合について素因数分解して求めようとする。
  一見、O(NK)くらいで良いように思われるが、1000以下の素数は170個程度あるので、4(int)*1000*100*170 + overhead でMLEしてしまう。
  メモリを削減する解法と、計算を工夫する解法の2種類がある。
  メモリを削減する方法の一つは、vectorやunordered_mapなどを利用して何とか時間内に収める方法である。
  2や3などの素因数を因数6としてまとめることで、メモリを削減するようなことをするのも良いようだ。
  ２つ目のメモリ削減の方法は、メモ化せずにDPすることでNの分のメモリを1000でなく2で確保することができるというもの。[要追記1]
  計算を工夫する方法もあるようである。EkaingさんやEditorialの方法である。[要追記2]
  
SRM 570 Div2 Easy Chopsticks
[問題]
  様々な箸が一本ずつ用意されている。同じ長さの箸2本で1つのペアが出来る。
  最大でいくつのペアを作ることが出来るか？
  1 <= N <= 50
  1 <= len[i] <= 100
  
[解答]
  長さ -> 本数 という記憶を配列またはmapを用いて行う。
  配列の各要素 / 2 の和が答え。
  
SRM 570 Div2 Med RobotHerbDiv2
[問題]
  無限に広いグリッド上に、辺を共有するマスに移動することが出来るロボットがある。
  一度の実行で、数列A[]を順に実行することができる。数列の各々i番目に関して、
    1. A[i]だけ前進する
    2. A[i]回90度右回転する
  という処理を行う。
  T回の実行で、ロボットが初期位置から最終的に移動した位置までのマンハッタン距離を答えよ。
  1 <= T <= 100
  1 <= N <= 50
  1 <= A[i] <= 400000
  
[解答]
  (0, 0), 向き=0からスタートすると決める。右時計回りに順に構成されたdxdyを用いて、
    x += A[i] * dx[dir], y += A[i] * dy[dir];
    (dir += A[i]) %= 4;
  とする。これをN * T回繰り返す。
  
SRM 570 Div2 Hard CentaurCompanyDiv2
[問題]
  N個のノードをN-1本のケーブルで連結に繋げたネットワークが与えられる。
  このネットワークをHumanCompanyとHorseCompanyに分けたい。
  HorseCompanyは既にケーブルを沢山持っているが、HumanCompanyは一本もケーブルを持っていない。
  よって、HumanCompanyに分けるネットワークの部分グラフは連結でなければならない。
  HorseCompanyに分ける部分グラフは連結である必要はない。
  各々1つのノードも貰えない場合も含むものとして、分割の組み合わせの総数を答えよ。
  2 <= N <= 51
  |A| = |B| = N-1
  1 <= A[i], B[i] <= N

[解答]
  2つに分けるので、1つの会社に分ける方法を決めれば、もう片方の会社に分ける方法も定まる。
  HumanCompanyは必ず連結した部分グラフのネットワークが配分される。
  元のグラフが木であるので、部分木が配分されると言い換えられる。
  よって、ノードを一つも持たないグラフを認めた上で、与えられたグラフの部分木の総数を数え上げれば良い。
  
  どのようにして方法の数を数えればよいか。具体的に考えよう。
  ノードを一つも持たないグラフは個別に考えるとする。
  はじめに根v_rを決めよう。v_rを数え上げている木のグラフに含まれると決める。
  v_rの子を{v_a, v_b, v_c}とする。
  それぞれを頂点として、自身を含む部分木に対して、組み合わせの数が求まっているものとする。
  これを順にdp[v_a], dp[v_b], dp[v_c]とする。
  各々の頂点自身を含まない場合も考慮して、組み合わせの数はそれぞれ(dp[v_a] + 1), (dp[v_b] + 1), (dp[v_c] + 1)である。
  よって、v_rを含み、それを頂点とする部分木に対しての子の選び方は、それらの積となる。
  
  一般化して以下のような式を考えられる。
    dp[v] := 頂点vを含む部分木での総数
    dp[v] = Π (1 + dp[u]) if 辺{v, u}が存在する && uはv以下の部分木の頂点
  このdp[v]を、各頂点について計算する。根となる各頂点について、自身を含む部分木について数え上げる。
  
  このままだと、既に別の頂点を根として計算した組み合わせの数とパターンが重複してしまうので、
  一度根と決めた頂点は使わないようにsetに含めていくことにする。
  そうした上で全ての頂点について、自身を根としたときの部分木の組み合わせの数の和を計算する。
  最後に、一つもノードを持たない場合を考慮すれば解が求まる。
  
SRM 571 Div2 Easy FoxAndGame
[問題]
  複数回ゲームを行う。'o'は各ゲーム中1セットに勝利した時に得られる星で、
  "---", "o--", "oo-", "ooo" はそれぞれ、1ゲームで獲得した星の数を表す。
  N回のゲームの星で、各々上のような星の数が与えられるとき、得られる星の数の総和を求めよ。

[解答]
  N*3のループで'o'の数をカウントする。
  
SRM 571 Div2 Med FoxAndMp3Easy
[問題]
  "(数字).mp3"というファイル名が数字1から順にN個存在する。
  数字Nが与えられた時、これらを辞書順に整理せよ。
  例えばN=10のときは以下のように "1.mp3", "10.mp3", "2.mp3", "3.mp3", ... と並べられる。
  Nが50より大きければ、はじめの50要素のみ出力せよ。
  1 <= N <= 1000

[解答]
  数字を1〜Nまで探索し、各々文字列に変換して配列に保持する。
  配列をソートして、各要素に".mp3"を付け足せば良い。
  
SRM 571 Div2 Hard MagicMoleculeEasy
[問題]
  N個原子がある。各々magicPower[i]を持つ。また、幾つかの原子は2つのペアになって分子を形成している。
  集合Sは、N個の原子のうち幾つかを含む。全ての分子のにおいては、少なくとも一方の原子がSに含まれなければならない。
  Sの要素数はちょうどKである。Sに含まれている原子のmagicPower[i]の和を最大化せよ。
  1 <= N <= 50
  1 <= K <= 14
  1 <= magicPower[i] <= 100000
  magicBond: [String] ; 無向グラフの隣接行列
  
[解答]
  頂点被覆問題であり、NP完全である。天下り的な説明だが、全探索をするしか無い。
  O(N^2)でSに含む分子の一つを全探索し、そのうちどちらの原子を使用するかを決めて、それをK回繰り返すDFS。O(N^2 * 2^K)
  分子を選択できなくなったら、それまでに選んだ分子のうちの原子のmagicPowerの和を求める。
  まだ残りk要素集合に含められる場合(残りk回ある場合)、加えて選んでいない全ての原子のmagicPowerを大きい順にk回加える。O(NlogN)
  全体でO(N^2 * 2^K) 最大でも4 * 10^7程度。
  
SRM 572 Div2 Easy EasyHomework
[問題]
  数列A[i]の各要素全ての積を0, 正, 負 のいずれかであるか判定せよ。
  -10^9 <= A[i] <= 10^9

[解答]
  負の値の数を数える。また同時に0があるかどうかも調べる。
  
SRM 572 Div2 Med NextOrPrev
[問題]
  以下の操作をいずれかの操作を選んだ文字に対して実行することができる。
  これを繰り返した時、文字列Sから文字列Tまで遷移するのに掛かる最小コストを求めよ。
  また、遷移不可能なら-1を示せ。
    1. z以外の文字をアルファベット順で一つ進める。その際のコストはnextCostである。
    2. a以外の文字をアルファベット順で一つ戻す。　その際のコストはprevCostである。
  1 <= |S|, |T| <= 26
  文字列S, Tの要素はいずれも重複しない。

[解答]
  (i, j)ペアについて、(S[i], S[j])と(T[i], T[j])とで、辞書順の関係が逆転していれば-1となる。
  そうでない場合は、diff = T[i]-S[i]の正負でnextCostかprevCostか選択して、diffを掛けたものを足し合わせれば良い。
  
SRM 572 Div2 Hard DistinctRemainders
[問題]
  N, Mが与えられる。以下の性質を全て満たす数列S[] = {S[1], S[2], ..., S[K]} の組み合わせの数をMOD10^9+7で求めよ。
    1. K >= 1
    2. S[i] >= 0
    3. S[1] + S[2] + ... + S[K] = N.
    4. S[1] mod M, S[2] mod M, ..., S[K] mod M は互いに異なる値である。
  1 <= N <= 10^18
  1 <= M <= 50

[解答]
  4より、1 <= K <= M-1 である。
  3, 4から、
        a_0 * M + m_0 + a_1 * M + m_1 + ... + a_{K-1} * M + m_{K-1} = N
        (a_kは任意の自然数。0 <= m_0 < ... < m_k < ... < m_{K-1} <= M-1)
  i.e.  M * Σ{k=0 to K-1}a_k = N - Σ{k=0 to K-1}m_k
  i.e.  Σ{k=0 to K-1}a_k = ( N - Σ{k=0 to K-1}m_k ) / M
  
  ここで、Σ{k=0 to K-1}m_k = X とおく。すなわち、
        Σa_k = (N - X) / M
  となる。Xを生成するパターン数は
    dp[i][j] := 0〜M-1(m_k)までの数のうちi個使用した時、それらの和がjとなる組み合わせの数。
  から、dp[i][X]で求めることが出来る。これは、O(M * M^2 * K)といった計算で求めることが出来る。
  あとは、上式より (N - X) % M == 0 となるときに 0 <= k <= K-1 のそれぞれに振り分ける方法を考えれば良い。
  これは即ち重複組合せであるので、
    nHr = n+r-1Cr
  という公式により求めることが出来る。よって、S[]の順列 i!個を考慮して、
    Σ{i=1 to M}Σ{j} combination((N-j)/M + i - 1, i - 1) * dp[i][j] * i!
  を求めればよい。
  combination(n, r)のnが巨大な数であるので、mod_inverseを使って求める必要がある。
  modの値が10^9+7で素数であることを利用すると、mod_inverseはフェルマーの小定理より繰り返し二乗法で求められる。
  
SRM 573 Div2 Easy SkiResortsEasy
[問題]
  非負整数列が与えられる。この数列を非増加関数とするために引かなければならない数の総和を求めよ。
  
[解答]
  左から順にdiff = A[i+1]-A[i]を計算して、diff > 0のときにresに加算し、A[i+1]-=diffとしていく。
  
SRM 573 Div2 Med TeamContestEasy
[問題]
  strength[]: [int] が与えられる。先頭の3人が自分たちのチームの構成メンバーの強さを示す。
  3人のチームの強さは、上位二人の強さの和である。即ちメンバーの強さをX, Y, Zとすると、
  X + Y + Z - min{X, Y, Z}がそのチームの強さである。
  3 * N - 3人についてはチームの組み合わせが未定である。自分たちのチームのランクは、
  自分たちの強さより大きいのチームの数+1で決まる。自分たちは最悪何位になりうるか求めよ。
  3 <= N <= 48

[解答]
  はじめに自分たちの強さを配列から取り除き、チームの強さXを求めておく。
  自分たちより強いチームには最も強い人は必ず起用させたいので、
  配列をソートしてから、強い人一人に加えてXを超えるために必要な弱い人一人を起用する。
  最後にチームの強さは決定したが、3人の帳尻合わせとして最弱をひとり入れる。
  これを繰り返すことの出来る回数+1が答えである。
  
SRM 573 Div2 Hard WolfPackDivTwo
[問題]
  グリッド上にN匹の狼が(x[i], y[i])にいる。各狼は1秒で辺を共有するマスに移動することが出来る。
  M秒後にちょうどすべての狼が同じマスにあつまる時の組み合わせの数を求めよ。
  2 <= N <= 50
  0 <= x[i], y[i] <= 50
  1 <= M <= 50
  (x[i], y[i])のペアは重複しない
  
[解答]
  題意を「全ての狼が原点から各々の指定した座標までM秒ちょうどで移動するための組み合わせの数」と読みかえる。
  dp[t秒][y座標][x座標] := 狼が原点からt秒後にマス(x, y)に動くための組み合わせの数
  全座標に対してのdxdyを用いた移動で計算できる。負の座標にも動くので、x, yそれぞれ適当に十分なオフセット
  +100などをして、原点を平行移動させておくと良い。
  Σ_k Σ_l Π_i dp[t][y[i]+offset + k][x[i]+offset + l] が答えとなる。
  
SRM 574 Div2 Easy CityMap
[問題]
  N*Mグリッドの各マスに'.'あるいは大文字のアルファベットが書かれている。
  グリッド上に存在するアルファベットの数を示す数列POIs[]が与えられる。数列の各要素は互いに異なる。
  数からアルファベットがどの数字に対応しているか調べて、順番に文字列の要素としたものを求めよ。
  1 <= N, M <= 50
  1 <= #(POIs[]) <= 26
  1 <= POIs[i] <= 2500
  
[解答]
  グリッドからアルファベットの数をmapなどで数える。
  mapをイテレートして、数値から逆に文字を求めて新しいmapTに入れる。
  T[POIs[i]]を順につなげた文字列を求めれば良い。
  
SRM 574 Div2 Med TheNumberGameDiv2
[問題]
  正整数A, Bが与えられる。Aに対し以下の2つの操作が可能である時、何度操作すればBになるか。
  それが不可能なら-1を示せ。
    左右反転させる。
    10で整数除算する。
  1 <= A, B <= 999999999
  A ≠ B

[解答]
  A, Bをそれぞれ文字列S, Tに変換する。
  (文字列: S, cost: 0)を初期状態としてBFSして、文字列Tとなるときのコストを求める。
  
SRM 574 Div2 Hard PolygonTraversal2
[問題]
  正N角形がある。これらの頂点を順に訪れる。ある頂点uから頂点vを訪れるとき、{u, v}間に線分を引く。
  既にA[]だけの頂点を順に訪れている。残りの頂点を訪れてA[0]に戻ってくるためには幾通りの方法があるか。
  ただし、新たに頂点を訪れるときは、今まで通ってきた線分に交差する線分を引くように訪れるものとする。
  4 <= N <= 13
  2 <= |A| <= N-1
  A[]の要素はすべて異なる。
  
[解答]
  (既に訪れた頂点S, 最後に訪れた頂点v)としてDFSする。
  線分の交差判定は、今いる頂点uから訪れる頂点vとで出来る線分の両側の点集合それぞれについて、
  少なくとも1つずつ既に訪れた頂点が存在しているかどうかを確かめれば良い。
  Div2 Hardはメモ化しなくても状態が少ないので通る。Div1 Med(450pt)は、このコードをメモ化すれば通すことが出来る。

SRM 575 Div2 Easy TheSwapsDivTwo
[問題]
  数列A[]の2要素をスワップしてできる数列のパターン数を求めよ。

[解答]
  初期状態は状態としてカウントしない。任意の2つの要素を選び、出来た配列を二分探索木などで管理する。
  その二分探索木の集合の要素数を答えれば良い。
  
SRM 575 Div2 Med TheNumberGameDivTwo
[問題]
  整数Nに対して、その1とN以外の約数をNから引くという操作を行うことが出来る。これを2人で交互に繰り返す。
  Nの約数が1またはNのみとなったとき、その手番が回ってきた人は負けである。
  両者が最善を尽くしたとき、先手と後手で勝つのはどちらか。
  1 <= N <= 1000

[解答]
  is_win[i]: [int] := 数iで手番が回ってきたとき、勝ちか負けか。(勝ち=1, 負け=0, 未計算=-1)
  先手と後手のどちらも同じ条件のゲームであるので、状態は数Nに対する一つだけでよい。
  これを用いて、動的計画法やメモ化再帰をして解く。
  初期条件として、is_win[1] = is_win[1から1000までの間の素数] = 0 としておくと良い。

SRM 575 Div2 Hard TheTilesDivTwo
[問題]
  左上を(0, 0)として、N*Mのグリッドがある。位置(i, j)について、i + j が偶数のマスは黒であり、奇数のマスは白である。
  グリッドの各マスには高々1つの駒が配置されている。このグリッドにL型のタイルを配置していく。
  タイルは以下のようになっている。
  O
  OO
  タイルについての条件は以下である。
    1. 一つのタイルは任意回数90度回転して配置することができる。
    2. タイルは駒の上に配置することは出来ない。
    3. タイル同士が重なることはない。
    4. タイルの角の部分は、黒色のマスの上に重ならなければならない。
  グリッドに置くことのできるタイルの最大枚数を答えよ。
  N <= 4, M <= 47

[解答]
  一行覚えるDPで解くことができる。
  DP[i][j][mask] := タイルの占有しうる４マスの左上を(i, j)として、j行目のタイルの配置状況をmaskで覚えている時の、タイルを置いた数
  実際はメモ化再帰して解いた。
  ４マスのうち、タイルの占有する３マスについて、駒が配置されているかと、覚えた一行からタイルの重なりと、角について黒の上にあるかを調べる。
  考え方は単純だが、実装が複雑にならないように注意する必要がある。
  解法の中心となる、「どのような方針や基準でタイルを置いていくか」に注意して、
  ミスのないようにシステマチックなコードが記述できる方法は何か考えてからコードを書き始めるのが良いと思われる。
  例えば、自分はタイルの向きにかかわらず、同じコードが書けるように注意した。
  初めは(i, j)をタイルの角に合わせて考えてみたが、それだと向きによってコードがばらばらになると判断した。
  一つの向きの判定自体に冗長な書き方をしても、i, i+1, j, j+1を変更しさえすれば他の向きも殆どコピペで対応できるコードを意識した。
  4回似たコードを書くことで、細かいミスに気付きやすくなる利点もある。
  また、マスが黒色である判定、コマが既に置かれているかの判定、タイルの配置と重なるかの判定をそれぞれ関数化することで、
  配置処理を行う関数内で気をつけることと、判定処理で気をつけることを分割させた。
  複雑な実装においては着眼している関数内で気をつけることを極力少なく抑えるとよい。
  着眼している関数内で考えたくないことは関数の内容を定義する前に関数名だけ充てがい、関数の使用法を決めてやるようなやり方が良いと思われる。
  解法の中心の関数が完成すれば、補助関数の仕様も明確になるので、一度書いた補助関数を書き直すような時間のロスを減らすこともできる。
  関数の大枠が完成したら、関数の中心部分を詳細に定める。
  それが終わったら、より細かい条件や境界判定、細かい部分の遷移の仕方にミスがないかを確かめる。
  例えばグリッドの配置問題では、行の切り替わりや配置の終了条件やその処理が正しいかしっかり検討する必要がある。
  遷移の仕方について、今回の問題では配置しない場合は1マスずつ下に移動していくが、配置する場合は2マスずつ移動していく。
  その時に条件分岐や遷移方法が間違っていないか検討する。
  
  まとめると、考え方より実装が面倒と思われる問題に対する解答は、例えば以下の様なアプローチを取ってみるとよいだろう。
    1. 解答の中心部分は何か。一番重要で、一番複雑そうな場所は何か。
    2. 中心部分の書き方の方針を見失いために、適切な考え方や基準は何か。
       適切な考え方や基準によって、コードが単純になったり、冗長でもシステマチックなコードにすることができるか。
    3. 構造化プログラミングによって、各実装の抽象化を図れ。実装している関数において考えるべきこと、そうでないことを見極めよ。
    4. 全ての境界条件は適切に処理されているかに注意せよ。
    5. 最後に、全体から部分に粒度を変えて見ていき、それぞれの意味とコードの一致を確認し、各段階が正確であることが諒解できてから解答を提出すると良い。

SRM 576 Div2 Easy TheExperimentDiv2
[問題]
  毎秒A[i]の水滴を落とすN個の機械が位置0から幅1の間隔で一列に並んでいる。機械の下側にM個の長さLのスポンジが左端をLeftEnd[i]で指定された位置として並んでいる。
  iは機械の位置から測って高さi+1の位置にある。水滴があるスポンジに落ちたら、その位置の下側にあるスポンジには水滴は吸収されない。
  各スポンジが1秒辺りに吸収する水滴の量を求めよ。
  1 <= N, M <= 50
  1 <= A[i] <= 1000
  0 <= LeftEnd[i] <= N-L
  
[解答]
  各々のスポンジについて、スポンジ0から順に範囲内にある水滴を加算する。
  一度スポンジに加算された水滴は今後使用しないようにsetにつめるなどしておくと良い。
  
SRM 576 Div2 Med 
[問題]
  N*Mのグリッドがある。各マスは'X'または'.'であり、'X'の上を歩くことが出来る。
  グリッドの最下部(y=N-1)は'X'で埋められており、プレイヤーはその上に立っている。
  今いる'X'の位置から上下で最も近い'X'について、その間の距離だけのはしごが有れば移動できる。
  ここで、コインがcoinRow, coinColumnの'X'の位置に置かれている。コインに到達するまでに
  必要な最小のはしごの長さを求めよ。
  1 <= N, M, coinRow, coinColumn <= 50

[解答]
  1. 左右に隣接する'X'をコスト0、上下はその間の距離をコストとしてダイクストラ
  2. BFS [要追記]
  3. 二分探索 [要追記]

  
SRM 576 Div2 Hard 
[問題]
  

[解答]


SRM 577 Div2 Easy
[問題]
  文字列Sがある。T = {'a', 'i', 'u', 'e', 'o', 'y'}として、Tの要素が連続しないようにしたい。  
  条件をみたすようにSから文字を取り除いた時、残った文字列の長さを答えよ。

[解答]
  集合Tの要素かどうか判定するis_vowel()関数 や set<char> vowel = {'a',...}などを、S上の隣接する文字に対して適用する。
  

SRM 577 Div2 Med EllysRoomAssignmentsDiv2
[問題]
  文字列集合T[]に空白区切りで参加者のレートが書かれている。参加者N人の部屋割りは、N人中ランダムに選ばれたR人ずつdistinctに割り振られる。
  Rは部屋の数を示し、Nが20で割り切れるときR=N/20、割り切れない時R=N/20+1として定義される。
  プレイヤーのレートは文字列T[0]の先頭の数値である。プレイヤーが最高位と同じ部屋に入る確率を求めよ。
  1 <= |T| <= 50

[解答]
  プレイヤーが最高位と同じ部屋にいる場合は大体の場合について1.0/Rである。ただし以下の場合に気をつける。
    プレイヤーが最高位の場合は1.0
    部屋が一つしかない場合も1.0
    プレイヤーが2位以下で上位R位に入っている場合は、必ず1からR位まで別の部屋になるので0.0
  
SRM 577 Div2 Hard
[問題]
  数列A[]をソートしたとき、隣り合う項が互いに素になるためには最小でいくつの数字を追加すればよいか。
  1 <= N <= 50
  1 <= A[i] <= 100000

[解答]
  まず数列をソートする。2数が互いに素かどうかはgcd(a, b) == 1かどうかで確かめられる。
  隣接2項を順に見ていき、ans = 0に以下のように加算する。
    1. 互いに素であるとき、条件を満たすので加算しない。
    2. そうでないならば、
      2-a. 数字を一つ追加すれば条件をみたす場合、ansに1を加算する。
      2-b. 一つ追加しても条件を満たさない場合、ansに2を加算する。こうすると必ず条件を満たす。
    gcd(a, a+1) == 1 が必ず成立する事実を考えると、なんかこの解答で良さげじゃないかと直感する。
    以下を参考にすると良い。[要追記]
    http://apps.topcoder.com/wiki/display/tc/SRM+577
    http://apps.topcoder.com/forums/?module=Thread&threadID=787732&start=0

SRM 578 Div2 Easy DeerInZooDivTwo
[問題]
  N匹のトナカイ。幾つかの角が取れてK個落ちている。2本の角が残っているトナカイの最小数と最大数を求めよ。
  1 <= N <= 50
  0 <= K <= 2 * N

[解答]
  1. return {max(0,N-K), N-(K/2+K%2)};
  2. return {max(0,N-K), N-(K+1)/2};

SRM 578 Div2 Med GooseInZooDivTwo
[問題]
  N*Mグリッドがある。各マスは'v'または'.'である。'v'にはgooseまたはduckが入る。gooseが入る条件は以下である。
    1. グリッド全体に少なくとも1匹はgooseが居る
    2. gooseがいる任意の'v'の位置からマンハッタン距離にしてdist以内の'v'には必ずgooseが居る
  グリッド全体の各'v'に対するgooseとduckの割り当て方の方法の数を求めよ。(mod 10^9+7)
  1 <= N, M <= 50
  0 <= dist <= 100

[解答]
  マンハッタン距離dist以内の'v'で塊を作ると、その塊の中に1匹でもgooseがいれば、
  それら全てがgooseで埋められていることになるので、一つの塊に対して割り当て方はgooseまたはduckの2通り。
  グリッド全体で最低1匹はgooseがいるので、答えは 2^(塊の数)-1(mod 10^9+7) となる。
  計算は繰り返し二乗法、あるいは単にO(n)でmodを取りながら計算すると求まる。
  ここで塊の作り方であるが、DisjointSet(UnionFind)で管理するか、BFSやDFSで同類を発見すると良い。
  例えばBFSをする事を考える。マンハッタン距離をメモする必要があるが、
  'v'が見つかった時点で距離dist[y][x]=0と更新するようにすれば塊をうまく作ることができる。
  またその場合は同じマスが複数回更新されてqueueに入る状態数が多くなるので、グローバル領域に置いておくのがよい。
  
SRM 578 Div2 Hard WolfInZooDivTwo
[問題]
  [0, N-1]の区間がある。各マスは最大1匹の狼を含むことが出来る。
  M個の区間の集合Sがあり、それぞれ[L[i], R[i]]である。Sの各要素の区間の中に少なくとも一匹の狼を含む。
  狼の配置の組み合わせの数を求めよ。(mod 10^9+7)

[解答]
  各マスについて、狼を置くか置かないかのパターンがある。
  置く場合の制限は特にないが、置かない場合の制限が区間の集合によって決まっている。
  マスiに狼を置かなくてもよいかどうかの判定には、そのマスより左側の直近の狼がどこにいるかの情報が必要。
  よって、以下の様なDPを考える。
    dp[マスi][最後に狼を置いた場所] := 組み合わせの数
  狼を置く場合は制限がないので、dp[i][i] = Σ{j<i} dp[i-1][j] と遷移できる。
  以下、置かない場合を考える。
    1. 直近の狼の座標jが区間k内に含まれているなら、必ずしもマスiに置かなくても良い。
    2. 直近の狼の座標jが区間k内に含まれていない、かつマスiが区間kの右端より左側なら、まだ右側に配置される場合があるので置かなくても良い。
    3. 直近の狼の座標jが区間k内に含まれていない、かつマスiが区間kの右端ならば、必ず狼を置く必要があるので不適。
    4. 直近の狼の座標jが区間k内に含まれていない、かつマスiが区間kの右端より右側なら、そのような場合は条件より不適。
  よって、置かない場合は以下のように遷移できる。
  dp[i][j] = dp[i-1][j]  (適する)
  dp[i][j] = 0           (不適)
  
  全体で(座標を1originとして)マスNまで見たとき最後においた狼の場所が任意の場合を考えて、Σ dp[N][i] が答えとなる。

SRM 579 Div2 Easy
[問題]
  N体の敵を任意の順で倒す。i番目の敵は強さA[i]である。敵を倒すには敵の強さより大きい強さを持つ必要がある。
  はじめ自分の強さがSで、敵iを一体倒すと強さがA[i]/2増加する。最大で何体倒せるか。
  
[解答]
  昇順ソートして順に敵の強さを超せなくなるまで倒してその都度強さを増加させる。

SRM 579 Div2 Med UndoHistory
[問題]
  lines[]: [string]が与えられる。順に入力したときの総押下数を求めよ。
  押下数は、文字を1文字入力で1、クリックで2、エンターで1だけ増加する。
  lines[]の各要素を入力し終えたらエンターを押し入力文字列を確定させる必要がある。lines[]の次の要素に移るとき、
  （エンターを押す直前の）現在の入力文字列の状態を保って移るか、または履歴を利用して移るかを選べる。
  履歴は今までの確定した入力文字列の全てのprefix(空文字列, 文字列全体を含む)を選択することが出来る。履歴の利用にはクリックが必要である。
  
[解答]
  以下の2つを考慮して順に処理する。
    1. 現在の入力文字列(lines[i-1])から、次の入力文字列(lines[i])に遷移する。コストは文字列長の差分。
       そのためにはlines[i]のprefixがlines[i-1]でなければならない。
    2. 履歴(set<string> historyなどとする)を活用する。コストは文字列長の差分+2
  is_prefix(a, b) := aはbのprefixとなるか　という関数を作っておくと良い。
  それぞれの処理の後、エンターキーを押すのでres++する。
  また、新たな履歴を生成しておく必要があるので、lines[i]のprefixを全列挙してhistoryにつめる。

SRM 579 Div2 Hard MarblePositioning
[問題]
  N個の円を横に並べる。それぞれ半径radius[i]: [int]である。
  隙間なく並べた時、最左端の円が床に接している点から最右端の円が床に接している点までの距離を最小化せよ。
  2 <= N <= 8
  1 <= A[i] <= 10^9

[解答]
  Nが小さいのでnext_permutation()で順列を生成できる。
  サンプルの最後のケースのように、最適解において隣接する円がお互いに接しているとは限らない。
  よって、既に決定した円の位置を記憶しておく必要がある。0番目をx=0としてはじめる。
  0番目に配置する円からi-1番目の円まで考慮して、i番目の円を追加した時の位置を求める(maxをとる)。
  最右端の円の位置がその順列における解であり、全体の解の候補となる(minをとる)。O(N^2 * N!)
  sqrtの和を取る必要があるので、誤差には注意する。doubleでは計算の仕方によっては誤差死するのでlong doubleにしておくと良い。
  頻出問題ですが、これを少し難しくした似た問題が最近では ACMICPC アジアつくば大会 2015 で出ました。
  
SRM 580 Div2 Easy ShoutterDiv2
[問題]
  N匹のうさぎはそれぞれ時間間隔[s[i], t[i]]だけクラブに参加する。時間間隔を共有したうさぎ同士は友だちになれる。
  友達になれるペアの数を求めよ。
  1 <= N <= 50
  
[解答]
  rep(i, N) REP(j, i+1, N) res += max(s[i],s[j])<=min(t[i],t[j]);
  
SRM 580 Div2 Med
[問題]
  
  
[解答]
  
  
SRM 580 Div2 Hard
[問題]
  
  
[解答]
  
  
SRM 581 Div2 Easy BlackAndWhiteSolitaire
[問題]
  文字列Sが与えられる。'B'または'W'で構成され、これらが交互に並ぶようにするために
  書き換えなければならない最小の文字数を求めよ。
  
[解答]
  rep(i, N) a += "BW"[f] == S[i], b += "BW"[f^1] == S[i], f ^= 1;
  return min(a, b);
  
SRM 581 Div2 Med SurveillanceSystem
[問題]
  N個の場所が監視対象にある。各場所は'X'または'-'で構成されている。
  M個の監視カメラがある。各々は連続する長さLの場所にある'X'の数を数えることが出来る。
  カメラは監視対象の場所のどこかを始点としてちょうどLの分だけ監視している。監視結果がreports[]で与えられる。
  各場所について、1個以上の監視カメラに監視されている場合は'+', どの監視カメラにも監視されていない場合は'-'
  監視されているか監視されていないか判別がつかない場合は'?'を割り当てよ。
  1 <= N <= 50
  1 <= L <= N
  0 <= M <= L
  1 <= reports[i] <= N-L+1
  矛盾のある入力は与えられない。
  
[解答]
  解1)
  各場所について、その場所が長さLという条件から、実際いくつのカメラに監視されうるかを調べる。
  調べたカメラ台数とreports[]による情報との比較で判別することができる。
  xnum個の'X'を監視できる全てのカメラを考慮したとき、各々が場所iを確実に監視するのに十分な数を持つかどうかを調べる。
  確実に監視できるための数は、xnum個監視できるときのNこの場所全体のカメラ配置のパターン数とreports[xnum]との差分を考えてみるとよい。
  [要追記]
  
  解2)
  最大フローで解く。
  [要追記]
  
SRM 581 Div2 Hard TreeUnionDiv2
[問題]
  2つのN頂点の木A, Bの隣接行列が与えられる。Aの頂点iとBの頂点P[i]をつなぐ。ただしP[]は[0,N-1]のpermutationである。
  任意のpermutationを考えたとき、出来たグラフ中の閉路の長さがKとなるパスの数を最大化せよ。
  1 <= N <= 9
  3 <= K <= 7
  
[解答]
  K <= 7より、閉路はA,Bを必ず往復1周する（2周することはない）。また、N <= 9より、N!のpermutationを生成できる。
  よって、各permutationにおいて、distA[i, j] + distB[P[i], P[j]] + 2 == Kとなる数を数えて最大化すれば良い。
  各treeのdist[i, j]はWarshallFloyedで生成しておく。
  
SRM 582 Div2 Easy SemiPerfectSquare
[問題]
  a * b * b == N (1 <= a < b) となるとき、NはSemiPerfectSquareである。
  与えられたNがSemiPerfectSquareかどうか判定せよ。
  2 <= N <= 1000
  
[解答]
  a < b <= sqrt(N) である全ての(a, b)に対して、Nと一致するものはあるか調べる。O(N√N)
  
SRM 582 Div2 Med SpaceWarDiv2
[問題]
  N人の魔法少女がいて、各々magicalGirlStrength[i]の強さを持つ。
  M種類の敵がいて、各々enemyStrength[i]の強さを持ち、enemyCount[i]体いる。
  magicalGirlStrength[i] >= enemyStrength[j] のとき、魔法少女iは敵jを倒すことが出来る。
  敵を倒すと、倒した魔法少女の疲労が1上昇する。
  N人の魔法少女の疲労の最大値を最小化せよ。
  1 <= N, M <= 50
  1 <= magicalGirlStrength[i] <= 100
  1 <= enemyStrength[i], enemyCount[i] <= 100
  
[解答]
  高い強さを持つ魔法少女は、疲労の制限一杯に酷使させたい。
  また、高い強さを持つ敵から倒していく必要がある。
  よって、magical...[]を降順ソート、(en..Str.., en...Cnt)のペアで降順ソートして、端から使用していく。
  疲労の最大値は小さい順に総当りする。敵が最大50*100 = 5000体いるので、1から5000まで試せば良い。
  
SRM 582 Div2 Hard ColorTheCells
[問題]
  N個の列がある。はじめpos=0にいて、全てのマスを塗りつぶし終えるまでの時間を最小化したい。
    1. 同じマスにいくらでも留まり続けることが出来る。
    2. 隣接するマスに移動するためには時間1を消費する。
    3. 高々2つある隣接するマスのうち１つを塗りつぶすことが出来る。また、それを塗りつぶすのに時間1を消費する。
    4. 塗りつぶし終えたあと、そのマスが乾くまでに時間dryingTime[i]を消費するまでは、そのマスの上を通過することは出来ない。
    5. 最後のマスが乾くまでの時間は考慮せずに塗りつぶし終わる時間まで考えれば良い。
  2 <= N <= 7
  1 <= dryingTime[i] <= 10^5
  
[解答]
  塗りつぶしの順序O(N!)、各々のマスを右から塗るか左から塗るかO(N!)、塗りつぶしのシミュレーションO(N^2)
  全体でO(N^2 * 2^N * N!)程度で全探索する。
  マスの左端と右端はそれぞれ右から、左からのみしか塗りつぶすことが出来ない。
  また、N!のdo~while、2^Nのループ、シミュレーションのループでネストが深くなる。
  N! * 2^N で、順序と左右の状態が確定したら、solveSubProblem(vector<int> permutation, int S)などとすると良い。
  
SRM 583 Div2 Easy SwappingDigits
[問題]
  num: string が与えられる。任意の(num[i], num[j])を1度だけ交換してできるnumで最小のものを答えよ。
  交換しない(i == jの交換)場合も含む。leading0は認めない。
  
[解答]
  rep(i, N) REP(j, i+1, N) {
    if(i == 0 && num[j] == '0') { continue; }
    swap(num[i], num[j]);
    minimize(ans, num);
    swap(num[i], num[j]);
  }
  
SRM 583 Div2 Med IDNumberVerification
[問題]
  id: stringが与えられる。これが正しいものか識別したい。
  正しいIDは6桁のregioncodeからはじまり、YYYYMMDD形式の日付が続き、3桁の個人番号、最後にはチェックサムが1文字で構成される。
    1. regioncodeは配列S[]に含まれるもの以外は正しくない。
    2. YYYYMMDDはJan 1, 1990以上、Dec 31, 2011以下の日付である。leap yearも考慮する必要がある。
    3. 個人番号は000は正しくない。奇数ならば男であり、偶数ならば女である。
    4. チェックサムは、0<=x<=10の値で構成される。'X'のとき10を表し、他の値はその数字で表現される。
       計算式は x + a1*2^17 + a2*2^16 + a3*2^15 + ... + a16*2^2 + a17*2^1 = 1 (mod 11)で確かめられる。
  以上の考慮の元、idが正しいかどうかを調べ、正しければ性別を求めよ。
  |id| = 18
  
[解答]
  int days[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };  // 2月29日
  ...
  if(!isLeap(y) && m == 2 && d == 29) { return false; }
  条件の見落としがないようにする。
  
SRM 583 Div2 Hard GameOnABoard
[問題]
  '0', '1'で構成されたN*Mグリッドがある。先手が(x1, y1)を選ぶ。そのあと後手が(x2, y2)を選ぶ。
  (x1, y1)から(x2, y2)まで移動し、通ったマス(x1, y1), ..., (x2, y2)の各々のコストを
  c_0, c_1, ..., c_k とすると、Σ c_i が最小となるようなパスが選ばれる。
  先手はΣ c_iを最小化、後手はΣ c_iを最大化するようにマスを選ぶとき、Σ c_iの値を求めよ。
  2 <= N, M <= 40
  
[解答]
  rep(i, N) rep(j, M) minimize(ans, dijkstra(i, j) + cost[i][j] - '0');
  
  dijkstra(si, sj) {
    ...
    rep(i, N) rep(j, M) maximize(ret, minimum_distance_from_si_sj[i][j]);
    return ret;
  }
  
SRM 584 Div2 Easy TopFox
[問題]
  familyName: string, givenName: string が与えられる。
  空文字を含まない任意のprefixによってできるペアを連結した文字列の種類数を答えよ。
  
[解答]
  rep(i, N+1) rep(j, M+1)
    集合Sに familyNameの部分文字列(0, i) + givenNameの部分文字列(0, j) を加える。
  return Sのサイズ
  
SRM 584 Div2 Med Egalitarianism
[問題]
  友人同士である二人組は所持金の差がD以内という決まりがある。
  N人の間の友人関係が隣接行列で与えられるので、所持金の最高金額と最低金額の差の最大値を求めよ。
  差が無限大になる場合は-1を示せ。
  2 <= N <= 50
  0 <= D <= 1000
  
[解答]
  与えられた隣接行列をグラフとしたとき、それが非連結であれば、最高金額と最低金額の差の最大値は無限大になる。
  連結グラフであるとき、各頂点からの最大距離を調べて、その最大値*Dが答えとなる。
  WarshallFloyedで最短路を求めて、距離がINFのペアがあれば、-1
  そうでなければ max{dist[i][j]} を求めれば良い。
  
SRM 584 Div2 Hard Excavations2
[問題]
  N個の建物が埋まっている。各々はナンバリングされていて、場所iにはkind[i]の種類の建物があるという。
  K個の建物の発掘によって、集合found[]の種類の建物が発見された。発掘された建物の組み合わせの総数を求めよ。
  1 <= N <= 50
  1 <= kind[i] <= 50
  #(found[]) <= K <= N
  
[解答]
  各々の建物の種類 found[i] をいくつ使用するか useCnt (for found[i]) を決めて、
  useCnt 個だけの建物の選び方を MaxUseCnt (= kind[] に含まれる found[i] の数) 個の中から選ぶ。
    dp[i][remain] := 種類iまでの建物の選び方を決めて、残りの選ぶべき建物の数が remain 個あるときの選び方の総数
    dp[i][remain] = Σ dp[i-1][remain + useCnt[i]] * comb(MaxUseCnt[i], useCnt[i])
  dp[0][K] = 1 を初期条件として、 dp[found.size()][0] が答え。
  
SRM 585 Div2 Easy LISNumberDivTwo
[問題]
  A[]に含まれている単調増加部分列の数を求めよ。
  
[解答]
  seq[i-1] >= seq[i] の数cntを数える。最後の単調増加部分列を考慮して、cnt+1が答え。
  
SRM 600 Div2 Easy 
[問題]
  
  
[解答]
  
  
SRM 600 Div2 Med 
[問題]
  
  
[解答]
  
  
SRM 600 Div2 Hard 
[問題]
  
  
SRM 585 Div2 Med TrafficCongestionDivTwo
[問題]
  高さHの完全二分木で作られた道路がある。この道路上を車が走行する。
  各頂点を唯一つの車が訪れるとき、すべての頂点を訪れるのに必要な車の台数を求めよ。
  車は移動することも出来れば、ある頂点に停車することもできる。
  0 <= H <= 60
  
[解答]
  根以外を移動する車は、3頂点の二分木上を移動し、停車しない。
  Hが偶数のとき根では車が停車して、奇数のときは、根は3頂点の移動経路に属する。
  このようにすれば最適になる。解はHに対して一意(これは題意より自明)であり、メモなしの再帰で解を求めることができる。O(H)
  
SRM 585 Div2 Hard LISNumberDivTwo
[問題]
  
  
[解答]
  
    
SRM 586 Div2 Easy TeamsSelection
[問題]
  N人を交互に2つのチームに入れていく。先のチームは、A[]の順に人物を引き入れたいと思っている。後のチームは、B[]の順に同様である。
  二チームとも引き入れたい人物貪欲に選んでいくとき、n番目の人はどちらのチームに選ばれたかを示すような文字列を求めよ。
  2 <= N <= 50
  
[解答]
  for i in 0..<N := どちらの番か(i%2)
    for j in 0..<N := j番目の人を採用する(既に採用されていたらcontinue, 採用できるならばbreak)
  という二重ループで解く。既に採用されているかどうかは、used[N]などで管理する。
  
SRM 586 Div2 Med PiecewiseLinearFunctionDiv2
[問題]
  全体で1つの折れ線グラフを示すN個のプロットが与えられる。プロットのx座標はx=1から+1ずつ増加し、y座標はY[i]である。
  query[] が与えられるので、 F(x) = query[i] の解の個数(折れ線グラフとquery[i]との交点数)を求めよ。
  query[i] に対する解が無限にある場合は、個数を-1とせよ。
  2 <= N <= 50
  
[解答]
  ダブルカウントを防ぐために、プロット上と隣接プロット間の2つの場合に分けて、交点数をカウントする。
  隣接プロット間にquery[i]があるかどうかの判定を関数化すると、プロットの上下をswapで調整できるなどしてコード書きやすくなる。
  
SRM 586 Div2 Hard StringWeightDiv2
[問題]
  文字列の重みは、出現する各アルファベットの、最初の出現位置と最後の出現位置の差の総和で計算される。
  文字列の長さLが与えられたとき、重みが最小となるような文字列の数を MOD 10^9+9 で求めよ。
  1 <= L <= 1000
  
[解答]
  1. L <= 26 までは、アルファベットの各種類を高々1個ずつ使用することで、文字列の重みを0にすることができる。26_P_L通り
  2. L >= 27 のとき
     先ず、出現するアルファベットについて種類ごとに全て隣接させておくと、文字列の重みを最小にすることが出来る。
     全てのアルファベットが使用されるので、次にどのアルファベットを追加しても重みは+1されるのみである。
     よって、
     種類の順序を決めるpermutation(= アルファベット26種類を各々1個使用する) * 各文字で使用する文字の組み合わせ(L-26文字から各々0個以上選ぶ組み合わせの数)
     により解が求まる。26! * 26_H_{L-26} = {L-1}_C_25 を計算すればよい。MOD 10^9+9 を忘れない。
     
SRM 587 Div2 Easy InsertZ
[問題]
  文字列Sは'z'以外のアルファベットの英小文字で構成されている。
  文字列Tはのアルファベットの英小文字で構成されている。
  Sの任意の場所に'z'を複数個数挿入できるとして、Tを生成出来るか？
  
[解答]
  Tから'z'を削除して、Sと一致するか調べれば良い。
  
SRM 587 Div2 Med JumpFurther
[問題]
  無限に高い階段を登る。i(1<=i<=N)回目には、i段登るか停止するかの選択肢を選ぶことが出来る。
  badStep段目を踏んではならないとき、N回の行動で最大何段まで登ることが出来るか。
  1 <= N <= 2000
  
[解答]
  踏んではいけない段は1つしかないので、はじめに停止するか、停止しないで登り続けるかで、
  解は N*(N+1)-1 または N*(N+1)/2 の二通りに絞られる。
  実際にbadStepを踏むかどうかは、N回のループで確かめれば良い。
  
SRM 587 Div2 Hard ThreeColorabilityEasy
[問題]
  格子状のグラフがある。各格子の2つの対角線のうちどちらを引くかの情報が cells[]: [string] で与えられる。
  頂点を3色に塗り分けることはできるか？
  1 <= N, M <= 50
  cells[i][j] = 'N' または 'Z'
  
[解答]
  任意の (cells[i][j], cells[i+1][j], cells[i][j+1], cells[i+1][j+1]) について、
  'Z'('N')の数が奇数なら"No" そうでなければ "Yes"
  
SRM 588 Div2 Easy KeyDungeonDiv2
[問題]
  赤の鍵は赤の穴に刺さり、緑の鍵は緑の穴に刺さる。白の鍵は赤にも緑にも刺さる。
  N個のドアがある。各ドアはdoorR[i], dorrG[i]個の赤、緑の穴を持つ。
  ドアを開けるには、ドアが持つ穴に全て鍵を刺さなければならない。鍵は一度使ってもなくならない。
  ドアを開けられる数の最大数を求めよ。
  1 <= N <= 50
  
[解答]
  各々のドアの穴の数から赤、緑の鍵の数を引き、残った数を白でまかなえるなら、そのドアを開けることが出来る。
  そのようなドアの数を数えれば良い。
  
SRM 588 Div2 Med GUMIAndSongsDiv2
[問題]
  N個の曲があり、曲iはtone[i]の音階を持ち、長さduration[i]である。
  曲iの直後に曲jを歌う場合、待ち時間 |tone[i]-tone[j]| が余計にかかる。
  時間Tの間に歌える最大曲数を求めよ。
  1 <= N <= 15
  
[解答]
  解法1.
  dp[歌った曲の集合S][最後に歌った曲i] := かかった時間
  として、TSPのようなビットDPを行う。DP[][] <= Tであるとき、__builtin_popcount(S)の最大値を求めれば良い。
  計算量は 2^15 ^ 15 * 15 = 7372800 < 10^7 なので余裕。
  
  解法2'
  歌う曲にし対して、tone[i]の小さい順に歌うと最も短い時間で歌うことが出来る。よって、
  tone[]を基準に、(duration[i], tone[i])を昇順ソートすると良い。Nの制約により、歌う曲はビット全探索が可能である。
  時間T以内に収まる曲集合に対して、曲数の最大値を求めれば良い。
  
  解法2
  解法2'と同様、tone[i]の小さい順にソートして歌うと最も短い時間で歌うことが出来ることを利用すれば、
  DP[曲の番号i][歌った曲数j] := かかった時間
  として解くことができる。
  （ソートしておいて結局ビット全探索するくらいなら普通はこういうDPを書いてますよね）
  
SRM 588 Div2 Hard GameInDarknessDiv2
[問題]
  'A','B','.','#'で構成された、N*Mのグリッドがある。
  グリッド上をAliceが'A'からmoves:[string]の指示通りに順に動く。Bobは'B'から自由に動くことが出来る。
  AliceとBobは1秒ごとに辺を共有するマスに必ず移動する。
  BobはAliceに捕まるかどうか調べよ。
  1 <= movesを連結した文字列の要素数(=T) <= 2500
  
[解答]
  Aliceの移動に対して、Bobの位置としてあり得るパターンを全て列挙すれば良い。
  Bobが取れる位置がなくなった場合、Aliceの勝ち、そうでないならBobの勝ちである。
  O(T*N*M)程度。
  
SRM 589 Div2 Easy GooseTattarrattatDiv2
[問題]
  与えられた文字列の文字種類を1種類にするために必要な最小変更回数を求めよ。
  
[解答]
  最も多いの文字を数えて文字列の長さから引けばよい。
  
SRM 589 Div2 Med GearsDiv2
[問題]
  円形にN枚の歯車が並んでいる。各々はS[i]の方向('L'or'R')に回る。歯車は隣接する歯車と逆向きに回れば噛み合うという。
  幾つかの歯車を取り除いて、歯車を噛みあうようにするとき、取り除く最小枚数を答えよ。
  3 <= N <= 50
  
[解答]
  S[i-1] == S[i] の比較で、互いに異なるとき、S[i]を取り除くようにする（S[i]=' 'などとする）。
  そうすれば、S[i-1], S[i+1]のどちらも、S[i]が取り除かれたことが考慮されることになる。
  しかし歯車が円形に並んでいるため、このままでは比較開始位置sに対して、S[s-1]の扱いに困る。
  よって、s=1として、S[0]を取り除く場合と取り除かない場合の両方を試して、その小さい方を答えれば良い。
  
SRM 589 Div2 Hard FlippingBitsDiv2
[問題]
  長さNのビット列S、Nの約数のMが与えられる。以下の3操作が可能である(kは任意)。
    1. ある1ビットを反転させる。
    2. 先頭からk*Mビットを反転させる。
    3. 末尾からk*Mビットを反転させる。
  全てのビットを'1'とするために必要な最小操作回数を求めよ。
  1 <= N <= 2500
  
[解答]
  任意のMの倍数の位置で文字列をA, Bに分割する。
  A = string(S.begin(), S.begin()+k*M),
  B = string(S.begin()+k*M, S.end())
  
  Aについて、以下の2操作を選ぶような再帰を行う。
    1. 末尾Mビットの'0'を'1'とする数を数えて、string(A.begin(), A.end()-M)で再帰する。
    2. 全てのビットを反転させてから、操作1を行う。
  Bについては、文字列を反転させてから上の再帰を行う。
  2つの再帰の和の最小値を求める。
  
SRM 590 Div2 Easy FoxAndGomoku
[問題]
  N*Nのグリッドが'o','.'で構成されている。'o'が縦, 横または斜めに5個以上連続する場所があるかどうか調べよ。
  5 <= N <= 15
  
[解答]
  左上から右、下、右斜下、左斜下いずれかに5個連続する'o'があるかを調べればよい。
  
SRM 590 Div2 Med FoxAndGo
[問題]
  N*Nのグリッドが'o','x','.'で構成されている。'o'が他の'o'と辺を共有するとき、それらはカタマリとみなせる。
  新たに'x'をいずれかの'.'の上におく。'o'のカタマリの中にあるいずれの'o'も'.'と辺を共有しないカタマリがあれば、
  そのカタマリの'o'すべてを取り除くことが出来る。適当な場所に'x'を置いて、取り除くことが出来る'o'の数を最大化せよ。
  2 <= N <= 19
  
[解答]
  任意の'.'の場所に'x'をおいて、そのときに条件を満たすような'o'の数をBFSで数える。
  
SRM 590 Div2 Hard FoxAndShogi
[問題]
  N*Nのグリッド上に歩の駒'U','D'がいくつか置いてある。'U'の歩は上に,'D'の歩は下に動かせる。それ以外場所は'.'である。
  はじめの状態と合わせて、そこから駒を動かすことの出来る状態の数をMOD10^9+7で答えよ。
  2 <= N <= 50
  
[解答]
  列ごとに独立であるので、それらを個別に解いて掛け合わせれば良い。
  列について、上の駒から配置に矛盾の無いように動かせるだけ上または下方向に動かす。
  矛盾とは、例えば下の駒がその上の駒より下に配置できないならそのような場合は存在しないので0を返す。
  全ての駒の配置が完了したら1を返すようにして状態を数え上げる。
  状態の引数は(今の駒のindex, 前の駒を置いた位置)であり、メモ化再帰によってO(N^4)程度で解が求まる。
  
SRM 591 Div2 Easy LISNumberDivTwo
[問題]
  
  
[解答]
  
  
SRM 591 Div2 Med LISNumberDivTwo
[問題]
  
  
[解答]
  
  
SRM 591 Div2 Hard LISNumberDivTwo
[問題]
  
  
[解答]
  
  
SRM 592 Div2 Easy LittleElephantAndBooks
[問題]
  N冊の本があり、各々のページ数が与えられる。K冊読むとき、K冊の最小のページ数の次に多いページ数を答えよ。
  2 <= N <= 50
  1 <= K <= N-1
  
[解答]
  ソートして、先頭K-1冊のページ数の和とK+1冊目のページ数とを足し合わせたものが答え。
  
SRM 592 Div2 Med LittleElephantAndPermutationDiv2
[問題]
  1〜Nのpermutationによって作られる数列A, Bがある。整数Kが与えられたとき、M = max(A[0], B[0]) + max(A[1], B[1]) + ... + max(A[N-1], B[N-1]) >= K
  となるpermutationのペアの総数を求めよ。
  
[解答]
  A, Bを1〜Nが順に並ぶように初期化する。std::iota(v.begin(), v.end(), (初期値)) などが便利。
  Aでnext_permutationして、N個のループでMの値を求めて、M >= K となる場合cntをカウントする。
  A, Bの組み合わせは全て考慮できたので、Bの順列の方法の数を考慮して、cnt * N! が答え。
  
SRM 592 Div2 Hard LittleElephantAndArray
[問題]
  (A, A+1, ..., A+N) を各要素任意個数の数字を抜き取ったとき出来上がる単調非減少数列のパターン数を求めよ。
  数列の要素からすべての数字を抜き取ることは出来ない。またleading0を認める。
  例えば、ある要素"1047"から数字を抜き取った2つの要素"047"と"47"は異なるパターンとみなす。
  1 <= A <= 10^15, 0 <= N <= 100
  
[解答]
  (A, A+1, ..., A+N)の各要素について、ビット全探索をして抜き取る数字の集合Sについて、全ての数字を列挙する。
  A+N <= 10^15 + 100 より、各要素について高々2^16-1個の数字の列挙を行う。
  動的計画法は、はじめに全探索解法を考えてからグラフから余計なノードを削除して配列風に整列し直すと良い。辺の貼り方は二分探索を活用することで高速化出来る。

SRM 593 Div2 Easy RaiseThisBarn
[問題]
  長さNの文字列Sが'c'または'.'で構成されている。'c'の数が前後で一致するように2つに分割する方法の数を答えよ。
  2 <= N <= 50
  
[解答]
  はじめに'c'の数cntを数えて、cntが奇数なら0。
  cntが偶数のとき、先頭から'c'の数を数えながら、その数がcnt/2と一致するときの数を求めれば良い。

SRM 593 Div2 Med WolfDelaymaster
[問題]
  与えられた文字列が、レベルkの"wolf"を0個以上連結してできる文字列かどうか判定せよ。
  レベル1の"wolf" = "wolf", レベル2の"wolf" = "wwoollff", ... という風になる。
  例えば、"wolfwwwooolllfffwwoollff" は "VALID" である。
  1 <= N <= 50
  
[解答]
  先頭が'w'であり、そこから連続する'w'の数kを数えて、以後k個の'o', k個の'l', k個の'f'が続くかどうか調べる。
  これを繰り返す。これと矛盾するような文字列であれば "INVALID" 矛盾しなければ "VALID"

SRM 593 Div2 Hard MayTheBestPetWin
[問題]
  N匹のペットがいる。i番目のペットは最速でA[i], 最遅でB[i]でトラックを一周する。
  N匹を2つのグループに分け、各グループ1匹ずつトラックを順に1周回る。
  グループごとにかかる時間の和をとり、その差の最大値を最小化したものを求めよ。
  2 <= N <= 50
  1 <= A[i] <= B[i] <= 10000
  
[解答]
  A[]を使用するグループをS, B[]を使用するグループをTと決める。
    DP[iまで振り分けた][和がj] := そのような振り分けは存在するか
  上のDPによって、SはA[]を使用, TはB[]を使用、としたときのあらゆる振り分けによる差が求まる。状態空間は 100 * {(10000 * 100) * 2} 程度である。
  しかし、この振り分けでは、問題の定義の maxdiff(S, T) = max(|Σ_{in S} A[i] - Σ_{in T} B[i]|, |Σ_{in S} B[i] - Σ_{in T} A[i]|) の最大値が左右のどちらであるか識別ができない。
  SはA[], TはB[]を使うと決めてしまったが、SはB[], TはA[]を使う場合が最大かもしれない。両方の場合についてDP[i][j] = trueとなっていることになる。
  DP[i][j] = true となる和jを生成する集合S, Tについて、集合S, Tを反転させたときの和j'はDP配列のどこにあるだろうか？
  その場所がわかれば max(j, j') が解の候補となるので、その中で最小の値を見つければ良い。
  
  maxdiffの定義から計算を進めよう。
  maxdiff(S, T) = max(|Σ_{inS} B[i] - Σ_{inT} A[i]|, |Σ_{inS} A[i] - Σ_{inT} B[i]|)
  絶対値を外して、
  maxdiff(S, T) = max(Σ_{inS} B[i] - Σ_{inT} A[i], Σ_{inT} A[i] - Σ_{inS} B[i],
                      Σ_{inS} A[i] - Σ_{inT} B[i], Σ_{inT} B[i] - Σ_{inS} A[i])
  任意のiについて、定義より、A[i] <= B[i]
  即ち、Σ_{inS} A[i] <= Σ_{inS} B[i], Σ_{inT} A[i] <= Σ_{inT} B[i] であることから、

  maxdiff(S, T) = max(Σ_{inS} B[i] - Σ_{inT} A[i], Σ_{inT} B[i] - Σ_{inS} A[i])

  上式は、前述のとおり集合S, Tを反転したもののmaxをとる必要があることを示している。maxの左右の式の関係を探ろう。
  S ⊂ U, T = U \ S であることから、
  Σ_{inS} B[i] - Σ_{inT} A[i] = (Σ_{inU} B[i] - Σ_{inT} B[i]) - (Σ_{inU} A[i] - Σ_{inS} A[i])
                              = { Σ_{inU} (B[i] - A[i]) } - { Σ_{inT} B[i] - Σ_{inS} A[i] }
                              ≡ W - { Σ_{inT} B[i] - Σ_{inS} A[i] } とおく。
  よって、W に関して2式 Σ_{inT} B[i] - Σ_{inS} A[i], W - { Σ_{inT} B[i] - Σ_{inS} A[i] } は対称である。
  図示したとき、2式の中点に当たる場所は {W - (Σ...) + Σ...} / 2 = W / 2 である。
  以上より、解として適切なものは、W / 2 以降のDPの値となる。このうち最小のDP[N&1][j] = true となる j が解である。
  
SRM 594 Div2 Easy FoxAndClassroom
[問題]
  N*Mのグリッドがある。任意の位置からはじめて、右下の座標に移動することを繰り返す。
  端まで来た場合は、y, x 座標それぞれについて mod N, mod M を取るようにする。
  全てのマスを通過することが出来るか？
  2 <= N, M <= 10
  
[解答]
  N, Mが互いに素なら可能。それ以外は不可能。
  
SRM 594 Div2 Med AstronomicalRecordsEasy
[問題]
  ある太陽系を観測する。惑星の部分集合S, Tについて、それぞれ恒星からの距離を観測したデータA[], B[]が与えられる。
  A[], B[] は単調増加列で、それぞれN, M個の惑星までの距離が与えられている。A[]の要素とB[]の要素とで同じ惑星を観測している場合もあれば、そうでない場合もある。
  A[], B[] の情報から、この太陽系には少なくともいくつの惑星が存在することが分かるか？
  2 <= N, M <= 50
  
[解答]
  任意の (A[i], B[j]) (0<=i<N, 0<=j<M) について、同一の惑星を観測しているとする。
  各々に B[j], A[i] を掛けることで、値が一致する。よって、A[]の各要素にB[j]、B[]の各要素にA[i]を掛けた配列a[], b[]を作る。
  a[]について、B[]の要素がいくつ存在するかを求める。これをcnt個とすると、解の候補として N + M - cnt が生じる。b[]についても同様である。
  全体でO(N^3)からO(N^4)程度で解を求めることが出来る。
  
SRM 594 Div2 Hard 
[問題]
  
  
[解答]
  

SRM 595 Div2 Easy LittleElephantAndBallsAgain
[問題]
  長さNの文字列Sがあり、各文字は'R','G','B'のいずれかで構成されている。一度の操作で文字列の先頭または末尾から1文字取り除くことが出来る。
  文字列Sに含まれる文字を全て同じ色にするまでに最小で何回の操作を行う必要があるか。
  1 <= N <= 50
  
[解答]
  N - 同じ文字で構成されている最大の部分文字列の長さ が答えである。

SRM 595 Div2 Med LittleElephantAndIntervalsDiv2
[問題]
  要素Mの列がある。各マスは白黒に塗ることが出来る。はじめは全て白に塗られている。
  N個ある区間[L[i], R[i]]について、順に全て白または全て黒に塗りつぶすことが出来る。
  最終的に出来あがる列の色のパターン数を答えよ。
  1 <= M <= 100
  1 <= N <= 10
  
[解答]
  N回の塗りつぶしをそれぞれ白または黒の両方を試す全探索のDFSを行う。O(M * 2^N)

SRM 595 Div2 Hard LittleElephantAndXor
[問題]
  正整数A, Bに対し、0 <= X <= A, 0 <= Y <= B である(X, Y)を考える。
  正整数Cに対し、X XOR Y <= C である(X, Y)の数を答えよ。
  1 <= A, B, C <= 10^9
  
[解答]
  A, B, C が10^9と大きい。XORに関する数え上げなので、A, B, Cをビットで扱う数え上げ、即ちビットの桁DPを考えればよい。
  「XがAまで」「YがBまで」「X XOR YがCまで」という3つの制限があるので、
    dp[i桁目][丁度Aか][丁度Bか][丁度Cか] := パターン数
  という桁DPの典型解法を適用する。
  場合分けは如何にするべきだろうか。綺麗で短い解法を考えるより先に、愚直（冗長）だが確実な方法を考えよう。
  DPにおいて、確実な遷移を記述するためには、全ての排反な状態をもれなく列挙する必要がある。
  その列挙が出来れば、各状態について計算した結果を次の状態とする遷移を書き下すだけである。
  もちろん遷移を書き下す際、制約より不適な遷移となるものがあれば、もれなく排除する必要がある（例えば今回であれば、X XOR Y <= Cという制約がある）。
  不適な遷移かどうかの判別は状態ごとに異なる場合がある。例えば、状態[i][0][0][0]に対して、X, Yはそれぞれ0, 1のどちらをとっても良いが、
  状態[i][0][0][1]に対しては、X XOR Y <= Cの制限が効いている。また、状態[i][0][1][0]であれば、Yは(Bのビット列)[i]以下の値しか取れない。
  幸い今回の問題では、状態は何桁目かを除けば、2^3(=8)個で手作業で列挙できる程度しかないので、統一的な記述がわからなければこの8パターン全てについての遷移を記述する事ができる。
  更に桁も、1桁前の桁状態しか考慮する必要はないので考えやすく、next[][][] += curr[][][] (curr[][][] += prev[][][]) という風に書く事ができる。
  
SRM 596 Div2 Easy FoxAndSightseeing
[問題]
  N個ある街から、街を1つだけスキップして、N-1個の街を順番通りに訪れる。
  今いる街から次の街に移るとき、それらの要素の値の差の絶対値だけのコストがかかる。
  コストを最小化せよ。
  3 <= N <= 50
  
[解答]
  訪れない街を一つ決め打ちした二重ループで解く。

SRM 596 Div2 Med ColorfulRoad
[問題]
  文字列Sが'R','G','B'で構成されている。RGBRGB...の順を保ったまま、S[0]からS[N-1]まで、いくつかをスキップして到達する。
  スキップにはコストがその位置の差の二乗分だけかかる。
  コストを最小化せよ。到達できない場合は-1を示せ。
  2 <= N <= 15
  
[解答]
  1. 使うマスを全探索し、RGB...の順に訪れているかどうかをチェックして最小化する。O(2^N * N)
  2. DP[位置] := コスト で最小化する。O(N^2)

SRM 596 Div2 Hard
[問題]
  
[解答]
  
SRM 597 Div2 Easy LittleElephantAndDouble
[問題]
  配列の任意の要素を任意回数２倍することができる。すべての要素を同じ数に揃えることが出来るか答えよ。
  1 <= N <= 50
  1 <= A[i] <= 10^9
  
[解答]
  各要素が「要素の最大値の約数」かつ「立っているビットの数が1」を満たせば良い。
  
SRM 597 Div2 Med LittleElephantAndString
[問題]
  文字列S, Tが与えられる。一度の操作でSのある文字を先頭に追い出すことか出来る。
  SをTに変えるために必要な最小回数を求めよ。不可能な場合は-1を示せ。
  1 <= |S|, |T| <= 50
  
[解答]
  はじめに文字数を種類ごとに調べて、S, Tの一致を見る。
  各々の文字は、前に送り出す文字とそうでない文字に分類できる。
  よって、前に送り出す文字の最小回数 = N - (位置を変えない文字の最大数) で解が求まる。
  位置を変えない文字の最大数は、Sの(consecutiveとは限らない)部分列と、Tのsuffixによる部分文字列とが一致する最大の長さである。
  SとTの位置を後ろから走査する。それぞれの位置をi, jとして、i = j = N-1, cnt = 0と初期化する。
  文字が一致する場合はi--, j--, cnt++、一致しない場合はi--とすれば、N - cntが解となる。
  
SRM 597 Div2 Hard LittleElephantAndSubset
[問題]
  [0,9]の数字を1度以下ずつ用いて、[1,N]から任意個数選んだ数字を任意個数の集合に分割するパターン数を求めよ。
  1 <= N <= 10^9
  
[解答]
  使う数字の集合Sに対して、そのpermutationの数を求めておく。ただし、leading0や、Nを超える数は除く。この(S, cnt)ペアがM個あるとする。
  次に使う集合を選ぶメモ化再帰を行う。全ての(集合S, permutationの数)のペアに対して、使うか使わないかを全探索してメモする。
  M個の全てに選ぶ選ばないを決めたとき、1個以上選んであれば（即ち集合S > 0であれば）その状態をカウントすることができる。
  これを(S, cnt)ペアのcntの数だけを掛け合わせながらメモ化再帰することで、解が求まる。
  
SRM 598 Div2 Easy
[問題]
  
[解答]
  
SRM 598 Div2 Med
[問題]
  
[解答]
  
SRM 598 Div2 Hard
[問題]
  
[解答]
  
SRM 599 Div2 Easy MiniatureDachshund
[問題]
  初期の体重weightとして、体重が5000gを超えない範囲で食べることのできるミカン(各々mikan[i]g)の個数を最大化せよ。
  3000 <= weight <= 5000
  1 <= N <= 50
  
[解答]
  mikan[]を昇順ソートして、増えるg数が小さいものから食べていく。
  
SRM 599 Div2 Med BigFatInteger2
[問題]
  A^B は C^D で割り切れるかを判定せよ。
  1 <= A, B, C, D <= 10^9
  
[解答]
  Cを素因数分解したとき、全ての素因数において、それぞれをD倍したものをAの同じ因数のB倍したものが上回れば割り切ると判定できる。
  
SRM 599 Div2 Hard SimilarNames2
[問題]
  N個の文字列names[]を任意の順序で並び替えた配列をP[]とする。
  P[]の先頭L個の要素において、P[i]がP[i+1](0<=i<=L-2)のprefixとなるようなパターン数を求めよ。
  2 <= N <= 50
  1 <= |names[i]| <= 50
  Elements of names will be distinct.
  1 <= L <= N
  
[解答]
  先頭L個を除いたN-L個の順列を考慮せずに、names[]の任意の要素を先頭としてメモ化再帰で題意を満たすパターン数を数える。
  最後に各々の文字列を先頭とするパターン数に対して、(N-L)!を掛けたものを足し合わせれば良い。
