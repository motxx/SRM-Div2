SRM 600 Div2 Easy TheShuttles
[問題]
  N個のバス停が与えられる。バスは全てX人乗りで、一台のバスあたりbaseCost + X*seatCostだけの費用がかかる。
  一台のバスは一つのバス停にしか止まることが出来ない。バス停に止まっている人の数を表すcnt[]が与えられるので、
  全員を運ぶための最小の費用を求めよ。
  1 <= N <= 50
  1 <= cnt[i], baseCost, seatCost <= 100
  
[解答]
  Xを[1, 100]の範囲で総当りして、それぞれのバスの台数をcnt[i] / X + (cnt[i] % X > 0)で求める。
  バス停のバスの台数から、そのバス停に停まるバスの費用も求まるので、あとはそれを足し合わせたものの最小値を求めれば良い。
  
SRM 600 Div2 Med ORSolitaireDiv2
[問題]
  numbers[]: [int] から幾つかを選んで、それらを全てOR演算することでgoalを生成する遊びがある。
  numbers[]から幾つかの要素を取り除いたとき、goalを生成できないようにするためには最小でいくつの要素を取り除けばよいか。
  1 <= N <= 20
  1 <= numbers[i] <= 10^9
  
[解答]
  numbers[i]が、goalを生成する要素となりうる値かどうかは、(goal | numbers[i]) == goal で確かめられる。
  goalを生成する要素以外は無視してOR演算をする。使えるnumbers[i]の集合をビット全探索で列挙する。
  
SRM 600 Div2 Hard PalindromeMatrixDiv2
[問題]
  N*Mのグリッドがあり、各々'0','1'で構成されている。行と列それぞれに関して少なくともrowCount, columnCount個の回文ができるようにしたい。
  変更しなければならない値の最小数を求めよ。
  2 <= N, M <= 8
  
[解答]
  N + M <= 16なので、行と列それぞれについてビット全探索が可能。
  ある文字列が回文であるとは、先頭からx文字目と後方からx文字目が同じ文字であることである。行rと列cの交差部分は同じ文字であることから、
  A[r][c] = A[r][W-1-c] = A[H-1-r][c] = A[H-1-r][W-1-c] が成り立つことになる。
  よって、各行において、(r, c)と(r, W-1-c)を同じ連結成分に、(r, c)と(H-1-r, c)を同じ連結成分にするようにUnionFindする。
  （別のものを同じ値に割り当てる必要がある時はUnionFindによってグループ分けするのが有効）
  各連結成分に対して、'0','1'の数を数えて、その少ない方を変更するようにカウントして足し合わせれば良い。
  これを回文判定する全ての行・列についてビット全探索で行い最小値を求める。
  
SRM 601 Div2 Easy WinterAndMandarins
[問題]
  N個のバッグそれぞれの中に物がA[i]個ずつ入っている。K人に1人1つずつバッグを与える。
  中身の物の差の最大が最小となるようにバッグを選んだとき、その差を求めよ。
  
[解答]
  ソートしてi番目とi+K-1番目の個数の差を最小化すれば良い。
  
SRM 601 Div2 Med WinterAndCandies
[問題]
  数列A[]が与えれる。これに対して数字Kを宣言するとき、
  A[]から複数の要素を抽出してできた数列S[]の各要素は[1, K]を各々1つずつ、すべて含まなければならない。
  任意のKに対して、生成できる数列のパターン数を求めよ。
  1 <= N <= 50
  1 <= type[i] <= 50
  
[解答]
  mp <- type[]の数え上げ
  repeat i, from 1 to MAX
    ans += mp[i] * mul;
    mul *= mp[i];
  
SRM 601 Div2 Hard WinterAndReindeers
[問題]
  文字列Aのsubsequenceと文字列Bのsubsequenceの共通部分列で
  文字列Cを部分文字列として含むものの最大の長さを答えよ。
  1 <= |A|, |B|, |C| <= 2500
  
[解答]
  最長共通部分列問題はNP-hardである。2文字列間についてのLCSであれば、O(NM)で計算できる。
  今回、文字列CはAとBの共通部分列の部分文字列であるので、何らかの工夫によって時間内に解を求めることが出来る。
  A, Bについて、解の共通部分列の要素となるCの先頭位置と末尾位置のペアの候補を全て列挙する。最大(L/2)^2個あるので、O(L^2)
  A, Bの最長共通部分列を先頭と末尾からの両方について求める。O(L^2)
  列挙したCの先頭位置、末尾位置のペアを全て考慮して、先頭からのLCSと末尾からのLCSの和を最大化する。O(L^2)
  求めた最大値に文字列Cの長さを足したものが解となる。
  
SRM 602 Div2 Easy TypoCoderDiv2
[問題]
  TypoCoderでは、はじめレートが500である。1200を境に色が変わる。
  i(1<=i<=N)回コンテストに出場した後のレートが与えられるので、色が変わった回数を求めよ。
  
[解答]
  i回のコンテスト後のレートはvector<int> ratingで与えられるので、
  ratingのはじめに500を追加したvector<int>について、前から調べて色が切り替わるタイミングを数え上げる。
  
SRM 602 Div2 Med PilingRectsDiv2
[問題]
  与えられた長方形の幾つかを用いて、それらを任意の順序で積み上げた長方形群のintersectionが
  limit以上になるような長方形の枚数の最大値を求めよ。長方形はX, Y軸に平行であるように重ねなければならない。
  また、各々の長方形は90度回転できる。
  
  1 <= #(X[]), #(Y[]) <= 50
  1 <= X[i], Y[i] <= 200
  1 <= limit <= 40000
  
[解答]
  intersectionの面積は、重ねる長方形の左下端を合わせるようにして置いていくと面積を最大化できるので、その前提で考える。
  長方形は回転できるので、X[i], Y[i]の長い方をX[i]とするようにスワップして、X[i]を基準に長方形をソートしておく。
  X[i] < X[j] (i < j) であることから、iを固定してX[i]を選ぶ長方形群の最小のX、つまりintersectionの長方形のXに該当すると考える。
  すると問題は、limit/X[i] <= Y[j] を満たすj(j >= i)の数を数える問題となる。
  iを動かすことでそのようなjの数の最大値を求めることが出来る。
  
SRM 602 Div2 Hard BlackBoxDiv2
[問題]
  N*Mのグリッドは'B','.'で構成される。'B'はブロックであり、'.'はなにもないことを示す。
  このグリッドを正面から見た配置と、側面から見た配置が与えられる。
  グリッドを真上から見下ろした配置（つまり実際に置かれているブロックの配置）としてあり得るパターン数を求めよ。
  1 <= N, M <= 50
  
[解答]
  O(N^3M), O(N^2M), O(NM)の解があるので、順に説明する。
  1. O(N^3M), O(N^2M)
  http://apps.topcoder.com/forums//?module=Thread&threadID=808170&start=0  
  
  3. O(NM)
  はじめに正面、側面から見た配置の各々について'.'を無視してブロックのみの数を数える。そしてブロックのみのR*Cマスのグリッドとみなす。
  問題文は、「R*Cマスの各行・各列に少なくとも１つのブロックが存在するようなブロック配置の方法の数」を求めるものと言い換えられる。
  よって、ある行にブロックが１つもない、またはある列にブロックが１つもない、というような方法の数を求めるのが役立ちそうである。
  ここで包除原理を用いた解法を考える。
  行の集合 S = {r(0), r(1), ..., r(R-1)}
  列の集合 T = {c(0), c(1), ..., c(C-1)}
  として、それらの冪集合P(S), P(T)とする。P(S), P(T)の任意の部分集合s, tについて、
  |∪ A(s, t)| が答えである。ただし、
    A(s, t) := 集合s, 集合tに含まれる全てのマスが空であり、s, tに含まれないマスのブロックの置き方は自由とするときの配置状況
  とした。
  |∪ A(s, t)|の計算には、集合s, tの全探索を考えるとO(2^(R+C))かかる。
  しかし各行、各列を区別して扱う必要はなく、実際は空の行の個数、空の列の個数だけ全探索すればよいので、
    行の個数i(0 <= i <= R)の選び方について comb(R, i) 通り
    列の個数j(0 <= j <= C)の選び方について comb(C, j) 通り
  を掛けた計算をしてやれば良いこととなる。空の行、列以外は自由に配置するので 2^(R-i)*(C-j) 通りである。
  よって、解は Σ (-1)^(i+j) * 2^((R-i)*(C-j)) * comb(R, i) * comb(C, j) である。
  MODを取る問題なので、2のべき乗はオーバーフローしないようにpow2[2501]などの配列に事前計算しておくと良い。
  また引き算の計算は、代わりに MOD - ... の足し算とみなすことで正しく計算を行うことが出来る。
  包除原理の計算はO(RC)であるので、全体の計算量はO(NM)である。
  
SRM 603 Div2 Easy MiddleCode
[問題]
  文字列Sが与えられる。以下の操作をSがなくなるまで繰り返す。はじめ文字列Tは空である。
    1. Sが奇数文字であるとき、中央の文字を文字列Tに後ろから追加する。追加した中央の文字はSから削除する。
    2. Sが偶数のとき、中央2つの文字の小さい方を文字列Tに後ろから追加する。選んだ文字はSから削除する。
  文字列Tを答えよ。
  
[解答]
  if S.length is odd; T.append(S[N/2]) S.erase(S.begin() + N/2)
  else ;              T.append(select smaller between S[N/2-1] and S[N/2]) S.erase(S.begin() + (selected character pos))
  
SRM 603 Div2 Med SplitIntoPairs
[問題]
  N(N∈even)個の整数列をN/2個のdisjointなペアに分割したとき、ペアの積がX(X<0)以上となるようなペアの数を最大化せよ。
  2 <= N <= 50
  
[解答]
  Nが偶数なので、数列に負の数と正の数が偶数個ずつのときは解はN/2となる。
  負の数が奇数個、正の数が偶数個のとき、N / 2 - 「負の数の最大値✕正の数の最小値がX以上なら0、そうでなければ1」 が解である。
  ただ最も簡単な方法は昇順ソートして、隣接するペアがX以上である数をカウントすることである。
  いずれの方法でも積の計算ではlong longにキャストすることが必要である。
  
SRM 603 Div2 Hard GraphWalkWithProbabilities
[問題]
  
  
[解答]
  
  
SRM 604 Div2 Easy FoxAndWord
[問題]
  文字列集合Sから、文字列sを抽出する。Sからsを取り除いた集合をTとする。
  sを適当な場所で文字列A, Bに分割して、それらをスワップしてt = B + Aとした文字列tがTに含まれている場合、そのような数をカウントせよ。
  ただし {s, t} ({t, s}と同じ) が等しければ、同じカウントとみなす。
  
[解答]
  S[i]を[1, n-1]の全てについて分割し、左右反転したものを連結して、それがS[j](i≠j)と一致するか判定する。
  S[i]の選択、S[j]の選択、分割位置kの選択、文字列の生成で、O(N^4)で解を求められる。
  
SRM 604 Div2 Med PowerOfThreeEasy
[問題]
  原点から(x, y)まで移動することが可能かどうか判定せよ。
  ただし、k回目の移動には3^kの距離だけ右、または上に移動できる。
  0 <= x, y <= 10^9
  
[解答]
  3^20 = 3486784401 > 3 * 10^9 であるので、右または上に進むDFSを深さ20程度まで行えば、
  O(2^depth)で解を求めることが出来る。
  
SRM 604 Div2 Hard FoxConnection2
[問題]
  N頂点からなる木のうち連結なK頂点の選び方は何通りあるか？
  2 <= N <= 50
  
[解答]
  頂点v以下の部分木の頂点を選択するとして、K個の頂点を持つ連結な木を数え上げる。
  その際、頂点vの子の頂点を最も左のものとそれ以外とで2つに分けて、それぞれk個(0<=k<K), K-k個というように頂点vで使えるKを配分する。
  最も左側は頂点vの部分木として確定し、子を頂点uとおくと、頂点u以下のメモ化再帰で最適である。
  左以外はまだ頂点v以下について考慮する必要があるので、使える最も左の子をインクリメントして再帰を続ける。
  
  memo[部分木の頂点v][左からleftMost番目の子の頂点][K個の頂点を配分する] := パターン数
  
  memo[][][] = 1                                                   if K == 1
  memo[][][] = K == 1(頂点vに置く分) ? 1 : 0                         if leftMost == G[v].size
  memo[][][] = rec(v, parent, leftMost+1, K)                       if leftMost == parent
  memo[][][] = Σ rec(g[v][x], v, 0, k) * rec(v, parent, x+1, K-k)  otherwise
  
  という遷移で解が求まる。
  
SRM 605 Div2 Easy AlienAndPassword
[問題]
  文字列Sから一文字除いたものをパスワードとしたい。パスワードは何通り考えられるか？
  
[解答]
  一文字取り除いてsetに詰めてサイズを答える。
  
SRM 605 Div2 Med AlienAndGame
[問題]
  N*Mのグリッドが'W', 'B'で構成される。行を反転させる操作が任意回数可能である。
  'W'のみで構成されるの正方形領域を最大化し、その面積を答えよ。
  1 <= N, M <= 50
  
[解答]


SRM 605 Div2 Hard 
[問題]
  
  
SRM 606 Div2 Easy EllysSubstringSorter
[問題]
  文字列Sのうち、長さLの部分文字列を1度だけソートすることが出来る。
  そのようにして出来る文字列をTとしたとき、辞書順最小のTを答えよ。
  
[解答]
  開始位置iをループで決めて、
  string T = S;
  sort(T.begin() + i, T.begin() + i + L);
  とする。それらをsetに詰めて、*st.begin()を答えれば良い。
  
SRM 606 Div2 Med EllysNumberGuessing
[問題]
  数当てゲームを行う。guesses[i]で数が指定される。answers[i] = |guesses[i]-答え| である。
  答えが一意に定まる場合は答えを求めよ。answers[]に矛盾がある場合は、-2, 一意に定めることが出来ない場合は -1 を示せ。
  
[解答]
  guesses[i] - answers[i], guesses[i] + answers[i] を両方試す。
  candidates = {guesses[0] - answers[0], guesses[0] + answers[0]} を記憶し、i(1<=i<N)が、このどちらかに該当するかどうかを調べる。
  該当しない場合は、candidateから除外する。iのループの結果、どちらも除外された場合は-2である。2つとも残っている場合は-1, 1つだけに定まる場合はその値を出力すれば良い。
  
SRM 606 Div2 Hard EllysCandyGame
[問題]
  EllyとKrisでゲームをする。v[]の数を1つずつ交代で取る。取った値を得点に加算し、同時にv[i-1](i-1>=0), v[i+1](i+1<N)を2倍にする。
  Ellyからはじめたとき、互いに最善手をとったときの勝者、あるいは引き分けを判定せよ。
  1 <= N <= 10
  0 <= v[i] <= 1000
  
[解答]
  N <= 10なので、取る順番は高々10!程度しかない。取ることの出来る値の選択にO(N)かかるとして、O(N*N!)程度でDFSをする。
  最適戦略はminmax法を適用する。Ellyの勝ち = -1, Krisの勝ち = +1, 引き分け = 0 などと決めておいて、
  Ellyのとき、再帰での初期値はworst caseの+1, Krisのときは初期値-1から初めて、それぞれ数値を minimize, maximize する選択を取れば良い。
  
SRM 607 Div2 Easy BoundingBox
[問題]
  (X[i], Y[i])のペアがN個与えられる。全てを囲む長方形の面積を求めよ。
  2 <= N <= 50
  -100 <= X[i], Y[i] <= 100
  
[解答]
  repeat minimize(x1, X[i]); maximize(x2, X[i]); minimize(y1, Y[i]); maximize(y2, Y[i]);
  return (x2-x1) * (y2-y1);
  
SRM 607 Div2 Med PalindromicSubstringsDiv2
[問題]
  文字列Sの回文となる部分文字列を数え上げよ。
  1 <= |S| <= 5000
  
[解答]
  愚直にやるとO(N^3)である。まず回文判定をメモ化再帰する。
  int memo[5001][5001] = -1(not use), 0(not palindrome), 1(palindrome)
  とする。これを部分文字列の長さが小さい順に行う。すなわち、
  REP(len, 1, N+1) rep(i, N-len+1)
    ans += is_palindrome(i, i+len-1);
  というようにすれば良い。O(N^2)程度になる。
  部分文字列の長さを考慮せずに、rep(i, N) REP(j, i, N) ans += ...
  とすると、O(N^3)になるので注意。
  
SRM 607 Div2 Hard CombinationLockDiv2
[問題]
  N桁の連続したダイアルがあり、連続部分を一度に上または下方向に回すことが出来る。
  '9'の次に上に回すと'0'になり、'0'の次に下に回すと'9'になる。
  SからTに変化させるまでに必要な最小操作回数を求めよ。
  1 <= N <= 50
  
[解答]
  dp[今見ている桁][総移動量][今の桁の回す方向]みたいな感じのDP[要追記]
  
SRM 608 Div2 Easy OneDimensionalRobotEasy
[問題]
  文字列Sに従ってロボットが一次元上を原点から移動する。'L'なら左へ、'R'なら右へ移動する。
  -A未満, +Bより大きい位置には移動できないので、移動しようとした場合その場に留まる。
  Sを全て実行した時の位置を答えよ。
  
[解答]
  ループでその通りに実装する。
  
SRM 608 Div2 Med MysticAndCandiesEasy
[問題]
  N個の箱があり、それぞれ高々high[i]個、箱全体で合計C個のキャンディが含まれている。
  必ずX個以上のキャンディを得るためには最小でいくつの箱を開けばよいか？
  1 <= high[i] <= 50
  
[解答]
  出来るだけ開く箱を少なくするためには、開かない箱に入っているキャンディの数をできるだけ多くすれば良い。
  [要追記]
  
SRM 608 Div2 Hard BigOEasy
[問題]
  与えられたN頂点のグラフ上に長さLのパスがある。Lは可能なかぎり無限に大きくなりうる。
  Lを作るグラフの移動の組み合わせはLの多項式に収まるだろうか？
  2 <= N <= 50
  
[解答]
  閉路がなければ、移動は有限なので多項式時間に収まる。
  また、閉路が一つだけで一方向に進むのであればO(L)というように多項式時間に収まる。
  閉路の進行方向を選ぶことが出来たり、ある閉路から別の閉路に移動するように、閉路の移動の仕方に a*a*a*a*... 通りあるような場合はO(a^L)となり、
  多項式時間に収まらない。このようなグラフの判定は、ある点vから異なる一歩に移動して、再び点vに戻るようなものが2つ以上あるかどうか調べるとわかる。
  ワーシャるフロイドなどを活用することで判定が可能である。
  
SRM 609 Div2 Easy MagicalStringDiv2
[問題]
  文字列は、ある正の整数kに対してk個の'>'の後にk個の'<'が続いた文字列であるとき、magical stringと呼ばれる。
  '<','>'のみで生成される文字列Sが与えられる。この文字列をmagical stringにするために変更しなければならない最小の文字数を答えよ。
  2 <= N <= 50
  
[解答]
  最終的に、">>>...><...<<<" というような文字列が生成できれば良い。
  つまり、左半分は'<'となっている数を数えて、右半分は'>'となっている数を数えれば良い。
  
SRM 609 Div2 Med PackingBallsDiv2
[問題]
  R,G,BのボールがそれぞれR,G,B個ある。一袋に最大3つのボールが詰められる。
  同じ袋には全て同じ色のボール、または全て異なる色のボールを入れる事ができる。
  必要な袋が最小となるようにに詰めたとき、必要な袋はいくつか？
  1 <= R, G, B <= 100
  
[解答]
  誤解法として、variety setになるように出来るだけ詰めてから、same setを生成するものがある。
  正答は、variety setの数を全探索する。variety setは、選んだ数に対して3つのもの->2つのものと選んでいくのが最適である。
  variety setの数が定まると、same setの数は一意に定まる。
  R, G, Bが高々100個までしか無いので、variety setは[0, 100]の範囲で探索すれば良い。
  
SRM 609 Div2 Hard VocaloidsAndSongs
[問題]
  gumi, ia, mayuの三人がS曲の歌をうたう。それぞれ、丁度gumi, ia, mayuの数だけの歌を歌わなければならない。
  また、すべての曲は最低１人に歌われる必要がある。複数人で同じ曲を歌っても良い。
  歌い方のパターン数を求めよ。(MOD 1000000007)
  1 <= S <= 50
  1 <= gumi, ia, mayu <= S
  
[解答]
  dp[曲のindex][gumiの残り曲数][iaの残り曲数][mayuの残り曲数] := パターン数
  
SRM 610 Div2 Easy DivideByZero
[問題]
  数列Aに複数の値を付け足して、任意の数列の要素のペアの整数除算(大きい方)/(小さい方)もまた
  数列の要素であるようにするとき、最終的な数列の要素数を答えよ。
  1 <= #(A[]) <= 100
  1 <= A[i] <= 100
  
[解答]
  
  
SRM 610 Div2 Med TheMatrix
[問題]
  '0','1'からなるN*Mのグリッドがある。最大の市松模様の面積を求めよ。
  1 <= N, M <= 100
  
[解答]
  各行で各々のセルの左側にいくつの市松模様が並ぶかを調べて、ヒストグラムを作る。
  次に、右上を始点としてヒストグラムを下方向に調べて最大長方形を探索する。
  O(N^3)解法はこれでOK
  
SRM 610 Div2 Hard MiningGoldEasy
[問題]
  N*Mのグリッド上で、K日間金塊の採掘を行う。
  k日目には(event_i[k], event_j[k])の場所に生じる金塊が採掘でき、採掘場所を(y, x)とすると、
  N + M - |event_i[k]-y| - |event_j[k]-x| の量だけの金塊が取れる。
  一日ごとに同じ行、または同じ列ならば、自由に移動することが出来る。行と列を変えて移動することは出来ない。
  採掘できる金塊の量を最大化せよ。
  1 <= N, M <= 10^6
  1 <= K <= 50
  0 <= event_i[k] <= N
  0 <= event_j[k] <= M
  
[解答]
  グリッドサイズが大きすぎるので、実際に金が配置されている座標のみを考えた座標圧縮を行う。
  すると、1 <= R, C <= 50 として、R*C程度のグリッドサイズと考えることが出来る。
  このとき、R*Cグリッド外の座標に留まることは無駄があるため考慮しなくても良さそうである。
  よって、R*Cグリッド上でグリッドDPを行う。
    dp[k日目][y][x] := 採掘できる金塊の量
  として、座標(y, x)から、座標(y, nx)または(ny, x)に移動する。行または列の何れかしか変えることが出来ないことに注意。
  O(N^4)で解を求めることが出来る。
  
SRM 611 Div2 Easy 
[問題]
  
  
[解答]
  
  
SRM 611 Div2 Med LCMSetEasy
[問題]
  数列Aが与えられる。この中からいくつか選んで、そのLCMを取ったとき、Xに一致させることが出来るか？
  
[解答]
  まず、A[i]がXの要素となるかどうかで篩いにかける。具体的には、X % A[i] == 0 を満たすもののみ考慮する。
  条件を満たすA[i]全てのLCMを取ったとき、Xに一致するか調べれば良い。
  
SRM 611 Div2 Hard ElephantDrinkingEasy
[問題]
  N*Nのグリッドがあり、'Y', 'N'で構成されている。'Y'は水を示す。
  象がグリッドのちょうど外枠((N+1)*(N+1)グリッドの四隅を除いた端)の4方向から水を吸おうとする。
  象の鼻は直線的にしか伸ばすことが出来ない。また、象の鼻は他の象の鼻と交点を持つことは出来ない。
  出来るだけ多くの象に水を吸わせたとき、象の数を最大化せよ。
  2 <= N <= 5
  
[解答]
  Nが小さく、4方向全ての象の位置を考慮しても20箇所以内である。よって、象の配置 2^(4*N) で全探索する。
  bool used[N][N]など用いて、実際に象の配置が可能かどうか調べると良い。
  また、象の鼻が交差しないようにしたとき、象は自分から最も近くの水を吸うのが最適である。
  それが出来ない場合、そのような象の配置の組み合わせは不適である。
  
SRM 612 Div2 Easy LeftAndRightHandedDiv2
[問題]
  'L', 'R'で構成された文字列がある。方向のとおりに各場所で進行するとき、ぶつかる場合を数え上げよ。
  
[解答]
  "RL"の数を答えれば良い。
  
SRM 612 Div2 Med EmoticonsDiv2
[問題]
  ある絵文字を並べていく。はじめ1個の絵文字が描かれている。これに対し以下の2操作ができる。
    1. 描かれている絵文字をクリップボードに貼り付ける。
    2. クリップボードからペーストする。
  ちょうどS個並べるために行う最小の操作回数を答えよ。
  2 <= S <= 1000
  
[解答]
  dp[描かれている絵文字の個数][クリップボード上の絵文字の個数] := 最小操作回数
  とする。O(N^2)で計算可能。
  遷移をBFSで書いても良い。しかし何れにせよ上と同様の dp[][]:=最小回数 によるメモは必要である。
  
SRM 612 Div2 Hard PowersOfTwo
[問題]
  long longであるN要素の数列Aが与えられる。Aの各要素は2のべき乗である。
  Aの要素を幾つか用いて、それらの和をとったときに生成される数の個数を答えよ。
  1 <= N <= 50
  
[解答]
  与えられた数列を2進数における桁に対する数に変換する。数列は2のべき乗であるので、各要素必ずある一つの桁の数を増加させる。
  よって、各桁(即ち数列の各要素)を使用するかしないかで2進数の桁DPを行う事ができる。
  与えられた数が2のべき乗でなければ、一つの数が複数の桁に分かれているので2進数の桁DPで解くことができなくなることに注意。
  状態は(桁のindex, 繰り上がりのビット数)となる。値を現在の桁で使用するかどうか、つまり、indexにおいてビットを立てるかどうかで、
  2通りの再帰が起こる。もちろん、現在の桁で1つもビットがなければビットを立てる再帰は起こらない。
  理解のために与えられた数列の要素に重複する要素などを入れて考えてイメージすると良い。
  打ち止めは確実にそれ以上のビットが生じないindex == 63などとすると良い。
  
SRM 613 Div2 Easy TaroString
[問題]
  文字列Sが与えられる。ある同じ文字をすべて取り除く処理を任意回数行うことが出来る。
  操作のあと、文字列を"CAT"にできるか？
  
[解答]
  'C','A','T'が、順に1文字ずつ存在するかどうか確かめれば良い。
  
SRM 613 Div2 Med TaroFriends
[問題]
  一次元整数座標上にN匹の猫が配置されている。各々の座標をA[i]とする。それぞれの猫が左または右方向にXだけ移動する。
  移動の後、最も左にいる猫と最も右にいる猫との距離の差を最小化せよ。
  1 <= N <= 50
  |A[i]| <= 10^8, 0 <= X <= 10^8
  
[解答]
  ある二匹の猫について、それぞれXだけ移動したとき猫が向い合っていれば背を向けているときよりは距離が必ず短くなる。
  他に距離が短いパターンは、同じ方向を向いていて距離が変わらない場合である。
  そこで、先ず全ての猫の座標の座標をソートしておき、
    1. それらを同方向に進める（つまりその状態での最大の距離）
    2. 区切り位置を全探索して、その左側は右へ、右側は左へ進むような座標における最大の距離を求める。
  の2通りを試す。それらの最小値が解である。
  
  他の解法として、座標圧縮のような考え方がある。言い換えると、使われる座標は 10^8 よりずっと小さいということに着目する。
  実際、猫の座標として使われるのは、移動前と後で高々100通りしかない。
  そこで、最左端を全探索しよう。その左端に対して、左端以外の猫をできるだけ左に寄せる。左に動かすと左端を超えてしまうような場合は右に動かす。
  それでも左端より左に位置する場合は不適となる。そうでないものの最右端と最左端の距離の最小値が解となる。
  参考) http://topcoder.g.hatena.ne.jp/kojingharang/20140323
  
SRM 613 Div2 Hard TaroCards
[問題]
  N枚のカードがある。それぞれ2つの数 first[i], second[i] が書かれている。
  first[]はNの順列で構成されている。それに対し、second[]は、それぞれ[1, 10]の何れかの数である。
  書かれている数の種類がK以下であるカードの部分集合の選び方は何通りあるか？
  1 <= N <= 50
  1 <= K <= 2 * N
  
[解答]
  dp[カードのindex][何種類の数を使用したか][[1, 10]の値の使用状況] := パターン数 とする。空間計算量は 50 * 101 * 1024 である。
  dp[i+1][j][k] += dp[i][j][k]     // i番目のカードを使用しない
  dp[i+1][nj][nk] += dp[i][j][k]   // i番目のカードを使用する
  
  [1, 10]の使用状況(= k)はbitで管理する。
  nj, nk の決め方は以下のように行う。
  second[i]は使用状況nkに考慮させる。新たに使用する場合は種類数njを増加させる。
  first[i]が10以下であれば、[1, 10]の使用状況nkに考慮させる。新たに使用する場合は種類数njを増加させる。
  
SRM 614 Div2 Easy MicroStrings
[問題]
  正の整数A, Dが与えられる。non-negativeである数列B[]={A, A-D, A-2*D, ...} を考える。
  B[]を左から繋いでできた文字列を求めよ。
  
[解答]
  AをDでデクリメントしつつ、それが非負である間stringstreamに詰め続ける。
  
SRM 614 Div2 Med MinimumSquareEasy
[問題]
  二次元座標上にN個の点が与えられる。
  このうち少なくともN-2個の点をstrictlyに内部に含むような正方形の最小面積を答えよ。
  3 <= N <= 50
  -10^9 <= x[i], y[i] <= 10^9
  
[解答]
  2点以下はon boundaryでも良いと考えるのは面倒。
  よって考慮しない2点を全探索して、残りのN-2点を全てstrictlyに内部に含む正方形を考える。
  左上の座標は、(最小のx座標-1, 最小のy座標-1)で固定。正方形の辺の長さは条件分岐で求めてもよいが、
  より思考停止感のある方法として、二分探索でN-2個の点を含むようなサイズを求める方法がある。
  
SRM 614 Div2 Hard TorusSailingEasy
[問題]
  高さM、幅Nの二次元グリッドをトーラス状に巻く。
  元のグリッドの原点からx座標とy座標ともに+1、または、ともに-1するように、トーラスの表面をランダムウォークする。
  元のグリッド上の(goalX, goalY)の位置に到達するために必要な移動回数の期待値を求めよ。
  2 <= N, M <= 10
  
[解答]
  MODを取った二次元グリッド上の移動でトーラスを表しているが、これは即ち一次元上の移動に置換できる。
  よって、原点から(goalX, goalY)への移動を、原点から+a, -bへの移動とみなせる。
  a, bの算出には複数の方法がある。
  一つにはN*M-1通り全探索する方法がある。N*M<=100であることから十分間に合う。このときゴールに到達しない場合は-1とすれば良い。
  期待値計算にも複数の方法がある。
  
  方法1  DPを十分な移動回数だけ反復して確率計算して期待値を求める方法。
    dp[step][pos] := step回目で位置posに到達する確率
  と定義する。遷移は、
    dp[step+1][pos-1] += dp[step][pos]
    dp[step+1][pos+1] += dp[step][pos]
  pos == +a || pos == -b となったら、pos-1, pos+1への遷移は行わない（一度ゴールに着いた後に動くことはない）。
  DPによる確率計算なので（誤差を考えなければ計算上は）各々の移動回数に対して、その確率を正確に求めることが出来る。
  十分な移動回数であるが、計算時間の許す程度のもの、仮に10^5程度を考えるとよい。
  100回の移動に対して、その1パターンの移動が起こる確率が1/2^100 で小さいからといって、100回程度にしてはならない。（その「位置」に移動する確率はもっと大きい）
  
  方法2  連立方程式を立てて、ガウスジョルダン法で解く方法。
  
  方法3  期待値はa*bである。
  
  EmKjpさんのeditorial: http://www.slideshare.net/EmKjp/srm614-34320184
  
SRM 615 Div2 Easy AmebaDiv2
[問題]
  数Xから初めて、数列A[]を左から舐めたとき、Xと同じ数が有ればXを倍にする。
  最終的にXは幾つになるか。
  
[解答]
  1重ループで実装する。
  
SRM 615 Div2 Med LongLongTripDiv2
[問題]
  1回のジャンプで1またはBだけ進むことができる。T回のジャンプで丁度Dまで進むことが出来るか？
  1 <= D <= 10^18
  1 <= T <= 10^9
  2 <= B <= 10^9
  
[解答]
  1だけ進む回数を二分探索すればよい。
  D-Tをk(0<=k<=T)回B-1だけ進むと考えてO(1)で解く事もできる。
  
SRM 615 Div2 Hard MergeStrings
[問題]
  文字列A, Bが与えられる。数列X[],Y[]によって、以下のように文字列Cが構成される。
    length(X) = length(A) and length(Y) = length(B).
    For each valid i, X[i] < X[i+1].
    For each valid i, Y[i] < Y[i+1].
    For each valid i and j, X[i] != Y[j].
    For each valid i, C[X[i]] = A[i].
    For each valid i, C[Y[i]] = B[i].
  Cの一部が分かっていて、一部が不明('?')となっている。Cとして考えられる文字列の辞書順最小のものを求めよ。
  そのようなCが存在しない場合は、empty stringを示せ。
  1 <= |A|, |B|, |C| <= 50
  
[解答]
  要はA, Bの先頭から文字を1つずつ何方か選んで取り出していき、Cに該当するものの辞書順最小な文字列を求めれば良い。
  辞書順最小 = 最小化問題であるので、メモ化再帰でminを取りながらA[i]またはB[j]を取っていくようにする。
  
SRM 616 Div2 Easy WakingUpEasy
[問題]
  N個のアラームが順にvolume[i]で指定される音量で鳴る。N番目が鳴った後は再び1番目から順に鳴る。
  はじめの眠たさはSであり、アラームが一度なると、S = S-volume[i] と更新される。S <= 0 となれば起きる。
  丁度起きるときに鳴るアラームの番号を求めよ。
  
[解答]
  起きるまでSからvolume[i%N]を減らしていく無限ループで解くことが出来る。
  
SRM 616 Div2 Med ColorfulCoinsEasy
[問題]
  
  
[解答]
  復習が必要なやつ
  
SRM 616 Div2 Hard TwoLLogo
[問題]
  '.', '#'で構成されるN*Mのグリッドがある。'.'のスペースに、Lの形をしたブロックを2つ置きたい。
  Lの縦棒と横棒の長さは任意であるが、2つのLがマスを共有してはならない。
  そのような置き方は何通りあるか？
  2 <= N, M <= 30
  
[解答]
  ある'.'のマスから上方向にどれだけ'.'が続くか、右方向どれだけ'.'が続くかをそれぞれ求めておく。
  それらを用いて、2つのLがマスを共有しても良いとした場合の"自由な"配置パターン数を求める。
  そこから、"禁止パターン"としてマスを共有するパターンを引く。
  このような包除原理によってO(N^4)で解くことが出来る。
  引く場合は、2つのLの (縦棒, 縦棒), (横棒, 縦棒), (横棒, 横棒) それぞれの場合について、マスを共有する場合を考える。
  Lの縦棒[横棒]のマスを共有する分の長さ * マスを共有しない分の長さ... などとする。
  2つのLの縦棒と横棒のペアで 2*2=4 の組み合わせがあるので、それぞれのパターンで掛ける因子は4つずつになる。
  包除原理の"自由なパターン"においても、掛ける因子の数は同様に4つである。  
  Practice Roomに上がっているwriter解によると、O(N^5), O(N^6) の解法もあるらしい。
  
SRM 617 Div2 Easy SilverbachConjecture
[問題]
  整数nが与えられるので、和がnとなるcompositeな2つの数に分解せよ。
  20 <= n <= 2000
  
[解答]
  線形でi, n-iを素数判定する。
  
SRM 617 Div2 Med SlimeXSlimonadeTycoon
[問題]
  毎日朝にmorning[i]個の食べ物を仕入れる。賞味期限はstate_limit日なので、その日数後の日にすぐ捨てる。
  i日目にcustomer[i]の人数の客が来る。客一人あたり1個の食べ物を売ることが出来る。n日で最大いくらの食べ物を売ることが出来るか。
  
[解答]
  increment[i] = Σ morning[i]
  decrement[i+state_limit] = Σ morning[i]
  とする。i+1日以降で、decrement[i] > 0 となるものからiの早い順に客に与えていく。
  現在の在庫の増加は increment[i] - decrement[i] というようになる。
  
SRM 617 Div2 Hard MyVeryLongCake
[問題]
  長さNのケーキがある。NのN未満の約数だけの数がどれか一つ選ばれて、その数の分だけの人に分け与える。
  どの数が選ばれるか不明なので、事前にケーキを切っておく。ケーキはすべての人に同じ量与えなければならないが、
  切ったケーキのうち、consecutiveな位置のものであれば、同じ人に複数個与えることが出来る。
  事前に切ったケーキの数を最小にせよ。
  2 <= N <= 10^9
  
[解答]
  位置iで切るかどうかを考える。
  GCD(N, i) > 1 のとき、N/GCD(N, i)人に配るときのために、位置iで切る必要がある。
  逆に、GCD(N, i) = 1 のとき、Nのどんな約数の人数が来ようが位置iで切る必要はない。
  よって、GCD(N, i) = 1 (1<=i<N) となるiの数を数えれば、切る必要のない位置の数を求めることが出来る。
  N - (切る必要のない位置の数) で切るべき位置が求まる。
  GCD(N, i) = 1 (1<=i<N) となるiの数は、即ち「1〜Nの数のうち、Nと互いに素な数の個数」であるので、これはオイラーのφ関数で求まる。
  φ(n) = n * Π_{k=1}^{d} (1-1/p_k) (p_kはnの素因数) であるので、この式を用いて O(互いに素な素因数の数(Nに対してかなり小さい)) でφ(N)を求めることが出来る。
  よって、解は N-φ(N) である。素因数分解にO(√N)なので、全体でO(√N)で解が求まる。
  
SRM 618 Div2 Easy WritingWords
[問題]
  一文字あたり、1から数えたアルファベット順の数だけコストがかかる。文字列S全てに対するコストを求めよ。
  
[解答]
  rep(i, N) sum += words[i]-'A';
  
SRM 618 Div2 Med LongWordsDiv2
[問題]
  以下の条件より、文字列Sが嫌いであるかどうか判定せよ。
    1. consecutiveな文字が同じであるものは嫌い
    2. 文字x, yに対して、xyxyという順に現れる(consecutiveとは限らない)ものは嫌い
  
[解答]
  先ず、1を線形で判定する。
  次に、2を4重ループで判定する。a<b<c<dについて、S[a]==S[c] かつ S[b]==S[d]であれば嫌い。
  
SRM 618 Div2 Hard MovingRooksDiv2
[問題]
  (要約)数列A[]について、A[i]>A[i+1]となっていれば交換できる。A[]をB[]に変形できるか？
  
[解答]
  本来の問題文が難しいが、解法はBFSするだけ。
  
SRM 619 Div2 Easy GoodCompanyDivTwo
[問題]
  0〜N-1までの番号が各従業員に割り当てられている。
  従業員iについて、そのボスがsuperior[i]である。唯一、0番目の従業員のボスはいない。
  従業員iと従業員iのボスsuperior[i]は、ともに同じ部署に属する。
  また、各従業員iに従事する仕事の種類workType[i]が割り当てられている。
  ある部署について同じworkType[i]の値を持つものがいなければ、その部署はdiverseであるという。
  また、部署の関係に推移性は成り立たない。
  つまり、superior[z] = y, superior[y] = x であっても、xとzは異なる部署に属する。
  diverseな部署はいくつ存在するか？
  1 <= N <= 100
  
[解答]
  superior[]から、iとsuperior[i]が辺となる木が作られる。根は唯一ボスを持たない0番目の従業員となる。
  木の根から走査して、diverseな部署の数をカウントしていく。
  カウントの方法は、各々の頂点vにおいて、std::setにworkType[v]と子のworkType[c]をつめて子の頂点数+1と一致するかどうか調べるなどがある。
  
SRM 619 Div2 Med ChooseTheBestOne
[問題]
  1からNの番号が振られた人を円形に並べてひとりずつ取り除く。
  1番の人から初めて、t回目にはt^3-1番の人を取り除く。
  最後に残る人を答えよ。
  N <= 5000
  
[解答]
  解法1.
  vectorにつめて、eraseしていく愚直なシミュレーションの解法で解くことが出来る。
  std::vector::eraseはO(N)なので、全体でO(N^2)
  3乗すると32bitに収まらないことに注意。
  
  vector<int> ps(N); iota(all(ps), 1);
  int pos = 0;
  REP(i, 1, N) {
    pos += ((ll)i*i*i - 1) %= ps.size();
    pos %= ps.size();
    ps.erase(ps.begin()+pos);  // O(N)
  }  // O(N^2)
  return ps[0];
  
  因みにPCK2014予選の7問目はstd::vector::eraseするとTLEする。
  
  解法2.
  DPするとO(N)になる。[要追記]
  dp[N-1] = 0;
  for(int t=N-2; t>=0; t--) {
    ll x = (ll)(t+1)*(t+1)*(t+1) % (N-t);
    dp[t] = (dp[t+1] + x) % (N-t);
  }
  return dp[0] + 1;
  
SRM 619 Div2 Hard EmployManager
[問題]
  earning[i][j]は、i < j となる従業員i, jについて、
    1. 両方雇用すると、利益がearning[i][j]増加する。
    2. 両方雇用しなければ、利益がearning[i][j]減少する。
    3. 何れか片方を雇用したときは利益の増減は起こらない。
  また、従業員iの雇用のコストにvalue[i]だけ掛かる。
  N人の候補者のsubset(including none or all of them)に含まれる人材を雇用したとき、(純)利益を最大化せよ。
  
[解答]
  一度全員雇用しない前提で考え、元の利益が Σ{0<=i<j<=N-1} -earning[i][j] であると考える。すると利益に関する条件は、
  P(i, j, 採用しない) = 0, P(iとjのうち1人採用) = +earning[i][j], P(iとjのうち2人採用) = 2 * earning[i][j]
  とみなせる。このようにするとi, jは独立に考えて良くなる。
  よって、各従業員iについて、雇用コストvalue[i]に見合うだけの価値を得られるかどうかだけを考えていけば良い。
  つまり、P(i) = Σ{0<=j<=N-1, i≠j} earning[i][j] として、P(i) > value[i] であれば、利益に P(i) - value[i] を加えれば良い。
  
SRM 620 Div2 Easy CandidatesSelectionEasy
[問題]
  スキルが0〜N-1までのN個あり、M人各々についてスキルの習熟度がscore: [string]で評価されている。
  習熟度の高さは最高が'A'であり、最低が'Z'である。
  スキルiについてのみ興味がある。スキルiが高い順にソートせよ。
  ただし、スキルiの評価がタイの場合は、人の番号が早い順に並べられる。
  
[解答]
  (score[i][x], i)のペアでソートして、そのペアの2番目のiを並べた配列を求めれば良い。
  
SRM 620 Div2 Med PairGameEasy
[問題]
  整数a, b, c, dがあり、(a, b)を(a+b, b)または(a, a+b)と遷移させることを繰り返す。
  任意回数の遷移の結果、(c, d)となるかどうかを求めよ。
  a, b, c, d <= 1000
  
[解答]
  現在の状態(x, y)を持ってDFSする。状態の変数が単調に増えるのでメモ化する必要はない。
  
SRM 620 Div2 Hard RandomGraph
[問題]
  N個の頂点があり、頂点同士はp/1000の確率で辺を持つ。
  構成されたグラフが少なくとも4つ以上の頂点の連結成分をもつ確率を求めよ。
  N <= 50
  
[解法]
  考察中...
  
  少なくとも4つ以上なので、高々3つまでの頂点の連結成分しか存在しない確率を求めて、1.0から引けば良い。
  
  だったら
  dp[連結成分が1個の部分グラフの個数][2個の部分グラフの個数][3個の部分グラフの個数] = その確率
  として、メモ化再帰すればいいんじゃね？（適当）

SRM 621 Div2 Easy TwoWaysSorting
[問題]
  S: [string]が与えられる。
  Sを以下の何れかに分類せよ。
    1. lexicographicallyにソートされている
    2. lengths昇順にソートされている
    3. 両方の形式でソートされている
    4. 全くソートされていない
  
[解答]
  Sをコピーした配列T, Uを作り、それぞれ通常にソートとlength基準のソートを与える。
  length基準のソートは、例えば sort(U.begin(), U.end(), [](string const& a, string const& b) { return a.size() < b.size(); }); とすれば良い。
  T==S&&U==S, T==S&&U!=S, T!=S&&U==S, T!=S&&U!=S の何れに当てはまるかを判別する。
  
SRM 621 Div2 Med NumbersChallenge
[問題]
  整数列A[]のsubsetの和で構成できない最小の正の整数を答えよ。
  1 <= N <= 20
  1 <= A[i] <= 100000
  
[解答]
  N <= 20 なので、subsetが全探索できる。その和を取ってstd::setなどにつめる。
  A[i]は高々10^5なので、subsetの和は高々20*10^5となる。この値を小さい順に1から全探索してsetに含まれているかどうか判別すれば良い。
  
SRM 621 Div2 Hard MixingColors
[問題]
  色が整数値で表される。立っているそれぞれのビットを原色として、各色はそれが1個以上混ざった色で表現される。
  色は無限にあらゆる種類数だけ売られている。購入した色は、いくら混ぜてもなくならない。
  色を混ぜる操作は、色と色のXORで行うことが出来る。colors[]を全種類揃えるのに買う必要のある色の種類数を最小化せよ。
  1 <= N <= 50
  
[解答]
  つまり、colors[]の全てを表現する事のできる最小の独立なベクトルの数を数えれば良い。
  PDFを読もう（提案）
  
SRM 622 Div2 Easy FibonacciDiv2
[問題]
  F[0] = 0, F[1] = 1 で定義されるフィボナッチ数列がある。
  整数Nが与えられたとき、最もNから近いフィボナッチ数列を答えよ。
  
[解答]
  a = 0, b = 1 として、F[i-2], F[i-1] を保存しながらフィボナッチ数がNを超えるまで求めていく。
  Nを超えた境界上で、超える前と超えた後とでNからの距離を測り、その最小値を求めれば良い。
  
SRM 622 Div2 Med BoxesDiv2
[問題]
  任意の1以上の2のべき乗の容量の箱がある。与えられた数列をそれらの箱に入れる。
  2つの箱の容量の和以上の箱で、2つの箱をマージすることができる。全てマージしたあと、残った箱の容量の最小値を答えよ。
  1 <= N <= 100
  
[解答]
  はじめに最小容量の箱でそれぞれの値を覆う。
  数列をソートした後、左2つ値の和以上の2のべき乗を作り、元の2つの値を削除する。
  この操作を箱の数が1個になるまで繰り返す。O(N^2 logN)程度
  
SRM 622 Div2 Hard Subsets
[問題]
  数列A[]を部分数列のうち、各要素の和が各要素の積より大きい物の数を求めよ。
  1 <= N <= 1000
  1 <= A[i] <= 1000
  
[解答]
  
  
SRM 623 Div2 Easy CatchTheBeatEasy
[問題]
  果物の初期座標が x[], y[] で与えられる。1秒あたりy = 1だけ地面y = 0に向かって落ちてくる。
  プレイヤーは地面y = 0上を左右に1秒辺り1だけ移動できる。果物がy = 0の位置に到達したときプレイヤーがその場にいればそれを取ることが出来る。
  いずれかの果物がy = 0となったときにプレイヤーに取られていないならば失敗である。全ての果物を取ることが出来るか？
  1 <= N <= 50
  
[解答]
  yが小さい順に果物の座標をソートして、順に取ることが出来るか試す。
  現在の座標から次の果物までのxの距離を求めて、yの差の時間内にその距離を満たせるかどうか判定していく。
  
SRM 623 Div2 Med CatAndRat
[問題]
  半径Rの円周上を猫と鼠がそれぞれ速さVcat, Vratで動く。はじめに鼠がt=0で円周のスタート位置に配置される。猫はt = Tに同じ位置に配置される。
  双方任意のタイミングで移動方向を変えることが出来る。方向を変える際の時間は掛からないものとする。
  双方が最適に動いたとき、猫が鼠を有限時間内に捕まえることが出来るか判定せよ。捕まえることが出来るなら、その時の時刻を求めよ。
  
[解答]
  まず 鼠の速さ >= 猫の速さ であれば、どうやっても猫は鼠を捕まえることは出来ない。
  次に、t = 0〜Tの間に鼠は出来る限りスタート位置から離れている必要がある。その距離は d = min(R * π, T) となる。
  よって、解は ans = d / (Vcat - Vrat) (if Vcat > Vrat), -1 (otherwise) である。
  
SRM 623 Div2 Hard ApplesAndPears
[問題]
  N*Nのグリッドが与えられる。各セルは'A','P','.'で構成されている。
  一度の操作で'A'または'P'は、'.'と入れ替えることが出来る。ある長方形領域について全て同じ文字であれば、その領域はuniformであるという。
  最大K回まで操作を行うことが出来るとき、uniformな長方形領域の最大面積を求めよ。
  1 <= N <= 50
  0 <= K <= 1000
  
[解答]
  ある長方形領域について、領域内部にある1つの'.'と領域外部の1つの'A'または'P'とを入れ替える操作は1回で行うことが出来る。
  また、領域内部の'A'または'P'を領域外部の'A'または'P'を入れ替える操作は、途中、領域内部の'A'または'P'と領域外部のある'.'と入れ替える操作を含めて、
  2回で行うことが出来る。この操作のためには、グリッド全体に1つ以上の'.'が存在する必要がある。(1つだけでも十分)
  領域内部を'A'または'P'で埋める場合、これらの操作をK回以内で済ますことが出来るかどうかを調べる。
  領域内部を'.'で埋める場合、領域内部の'A'または'P'を領域外部の'.'と入れ替える操作だけでよく、これをK回以内に済ます事ができるか調べる。
  長方形領域の探索にはO(N^4)かかるが、その領域内部に対しての'A','P','.'の数は包除原理を用いて事前計算することが出来る。
  領域外部に対しての個数は、全体から領域内部の個数を引いて求めれば良い。事前計算も長方形探索を行うので同様にO(N^4)かかる。
  全体でO(N^4)で解が求まる。
  
SRM 624 Div2 Easy CostOfDancing
[問題]
  各レッスンA[]だけコストがかかる。最小コストでK個のレッスンを受けるにはいくら払えばよいか。
  1 <= N <= 50
  
[解答]
  ソートして、左からK個の和を取れば良い。
  
SRM 624 Div2 Med BuildingHeightsEasy
[問題]
  数列A[]の各要素にいくらか足して少なくともM個以上が同じ値となるようにするとき、加算する数の総和を最小化せよ。
  1 <= N <= 50
  
[解答]
  A[i]に合わせるとすると、A[i]以下の値のみ考慮すれば良いので、それらを取り出して各要素A[i]との差分を取ったB[]を作りソートする。
  B[]の初めのM個の値の和を取り、それを最小化すれば良い。
  
SRM 624 Div2 Hard GameOfSegments
[問題]
  N頂点の凸多角形の対角線または辺上に2人が交互に線分を引く。ただし、既に引かれている線分と交差してはならない。
  先手か後手のどちらが必勝か？
  3 <= N <= 1000
  
[解答]
  N頂点の凸多角形に線分を引くと、i個の頂点とN-i-2個の頂点の凸多角形に独立に分割できる。
  つまり、g(N)からはg(i)とg(N-i-2)に遷移可能である。分割された凸多角形においても、同様の性質が成り立つ。
  これより grundy数 g(N) が0でなければ、先手の勝ちであることが分かる。
  
SRM 625 Div2 Easy AddMultiply
[問題]
  整数yに対して、(x[0] * x[1]) + x[2]) = y となる 整数列x[](-1000 <= x[i] <= 1000) のうち、0または1を含まない数列を答えよ。
  0 <= y <= 500
  
[解答]
  解法1
  y = 0, y = 1, y = 2 のときだけ条件を満たす x[] を適当に指定する。
  y >= 3 のとき、{-1, -1, y-1} が解となる。
  
  解法2.
  3重ループで、x[i]をそれぞれ-1000から1000まで動かす全探索をする。
  一見、計算量が最悪 2001^3 < 10^10 に見えるループでも、問題性質上すぐに解が定まることから解くことが出来る。
  
SRM 625 Div2 Med IncrementingSequence
[問題]
  N個の要素数をもつ数列A[]に対して、各要素について任意回数Kを加算することが出来る。
  数列A[]を[1, N]の全ての数を含む数列に変形できるか？
  1 <= K <= 10
  1 <= #(A[]) <= 50
  1 <= A[i] <= 50
  
[解答]
  元の数列の小さい数は変形後の数列の小さい数に割り当てるようにする。これをミス無く短いコードで実装したい。
  とりあえず数列をソートする。まず、[1, N]の数を順に調べることは必要である。
  A[i] == i+1 が成り立てば、数i+1は満たせる。A[i] > i+1 となれば、i+1を満たせないので変形不可となる。
  A[i] < i+1 のとき、とりあえずA[i]にKを加算しておき、再びソートしてルーブしていけば良い。
  O(N^2logN)程度で解が求まる。
  
SRM 625 Div2 Hard ConundrumReloaded
[問題]
  N人が円周上に並ぶ。各々正直者か嘘つきかであり、右の人間を「正直者」「嘘つき」「不明」と宣言する。
  与えられた宣言に当てはまる組み合わせのうち、嘘つきの数が最も少ないとき、嘘つきの人数を答えよ。
  条件に当てはまる組み合わせが存在しない場合、-1を示せ。
  1 <= N <= 50
  
[解答]
  典型的な方針として、円を切断して直線とみなし、先頭の状態を保存しておく方法がある。
  今回の場合、dp[i番目][先頭が嘘つきかどうか] := 嘘つきの最小人数 としたDPを行えば良い。
  
SRM 626 Div2 Easy SumOfPower
[問題]
  数列A[]の全てのcontiguousな要素で作られるsubsetについて、それらの和を取った値の合計値を求めよ。
  
[解答]
  3重ループでcontinugousなsubsetの和を計算し、足し込む。
  
SRM 626 Div2 Med FixedDiceGameDiv2
[問題]
  AliceとBobがそれぞれa面、b面の一様なサイコロを1つずつ振る。各サイコロの面には[1,a], [1,b]の数字が書かれている。
  サイコロを振ったとき、strictlyに大きい目を出した方が勝ちである。
  既に2人がそれぞれサイコロを振っていて、それぞれどの目が出たかは不明だが、Aliceが勝ったことは分かっている。
  Aliceの出した目の期待値を求めよ。
  
[解答]
  解法1.
  定義より、期待値 = Σ x * P(x) for 全てのあり得るx である。
  今回xはAliceの目となるので、1 <= x <= a の何れかの値となる。
  この計算をすればよいが、既にAliceが勝ったことが分かっているのでP(x)は条件付き確率となる。
  よって、実際は P(Aliceの目 = x | Aliceが勝つ全ての場合) を求める必要がある。
    P(Aliceの目 = x | Aliceが勝つ全ての場合) = P(Aliceの目 = x かつ Aliceが勝つ全ての場合) / P(Aliceが勝つ全ての場合)
  であるので、まずは P(Aliceが勝つ全ての場合) を求めよう。
  Aliceの目をx, Bobの目をyと置く。それぞれの目が出る確率がPa(x), Pb(y)のとき、それらは互いに独立事象であるので、
  P(Aliceの目 = x かつ Bobの目 = y) = Pa(x) * Pb(y) である。サイコロの目は一様な確率で出現し、Pa(x) = 1 / a, Pb(y) = 1 / b であるから、
  Pa(x) * Pb(y) = 1 / (a * b) (1 <= x <= a, 1 <= y <= b) となる。
  ここで、各ペア(x, y)が出る事象は排反である。x > y のとき、Aliceが勝つので、x > y を満たす全ての(x, y)について、その確率を足し込めば、P(Aliceがかつすべての場合)
  が求まる。これは即ち、Σ{i>j} Pa(x) * Pb(y) = Σ{i>j} 1 / (a * b) である。
  従って、
    Aliceが勝つときの出る目の期待値E(X)
  = Σ 出た目x * P(Aliceの目 = x | Aliceが勝つ全ての場合)
  = Σ 出た目x * { P(Aliceがxの目を出す かつ Aliceが勝つ全ての場合) / P(Aliceが勝つ全ての場合) }
  = Σ{x > y} x * { (1 / (a * b)) / (Σ{i > j} 1 / (a * b)) }
  = Σ{x > y} x * (1 / (x > yを満たす全ての(x, y)のペアの数)) (∵ 内側のΣを1/(a*b)で約分した)
  を計算すれば良い。O(N^2)
  
  解法2.
  Closed form formula for sum of squares により、O(1)で計算することも出来るようだ。
  参考) http://apps.topcoder.com/forums/wiki/x/aoE_/;jsessionid=85048720D8DC6298B5C589C93AA39B71?module=Thread&threadID=823470&mc=8&view=flat_new
  
SRM 626 Div2 Hard NegativeGraphDiv2
[問題]
  頂点1〜Nをつなぐ正のコストが割り当てられたM個の有向辺がある。辺は自己ループ、多重辺を含む。頂点1から頂点Nまで移動したい。
  また、高々K回だけ通る辺のコストを一時的に-1倍する事ができる。頂点Nに到達するための最小コストを求めよ。
  1 <= N <= 50
  1 <= M <= 2500
  1 <= K <= 1000
  
[解答]
  まず、負の辺に変換することをしないで任意の頂点間で最小コストを求める。N <= 50なのでWarshallFloyedすると良い。
  考えやすいように、頂点を0-indexedに変換する。
  負の辺する回数が高々x+1回の場合の部分解は、負の辺にする回数が高々x回の場合である。よって、
    dp[i][j] := j回負辺にしたときの、頂点iから頂点N-1までの最小コスト
  として、j=0からj=Kまで順に更新していくことが出来る。
  新たに1回多く負の辺にする場所を選ぶような更新処理を行う。即ち、
    dp[i][j] = dp[j-1]
    for k in 0..<M
      dp[i][j] = min(dp[i][j], dist[i][s[k]] - weight[k] + dp[t[k]][j-1])
  とすれば良い。
  
SRM 627 Div2 Easy ManySquares
[問題]
  N個の長さA[i]の棒が与えられる。同じ長さの棒を4つ用いて正方形をいくつ作ることが出来るか。
  
[解答]
  同じ長さの棒の数 / 4 を足し合わせれば良い。
  
SRM 627 Div2 Med HappyLetterDiv2
[問題]
  二つの異なる文字を任意の順番で消していったとき、最後に残る文字は固定されるかどうか。
  固定されるならば、その文字を答えよ。
  
[解答]
  過半数を占める文字があるかどうかで判定すれば良い。
  
SRM 627 Div2 Hard BubbleSortWithReversals
[問題]
  数列A[]が与えられる。高々K回だけ範囲がdistinctなsubarrayを反転させたとき、バブルソートの交換回数を最小化せよ。
  2 <= N <= 50
  1 <= K <= 1000
  
[解答]
  もう一度解いてから解説を書きます
  
SRM 628 Div2 Easy BishopMove
[問題]
  チェスのビショップの動き、即ち一回の移動当たり斜め4方向に任意の距離だけ移動して、(r1, c1)から(r2, c2)を目指す。
  移動回数の最小値を答えよ。また、移動できない場合は-1を示せ。
  
[解答]
  移動できる範囲が市松模様上になるので、r1 + c1, r2 + c2 の偶奇が一致しない場合は移動できない。
  移動できる場合、
    1. (r1, c1) == (r2, c2)が成り立つならば、移動する必要がないので 0
    2. abs(r1 - r2) == abs(c1 - c2) が成り立つならば、2マスを通る直線のマスがグリッド上にあるような移動なので 1
    3. それ以外の場合、2回で必ず移動できるので 2
  とすればよい。
  
SRM 628 Div2 Med BracketExpressions
[問題]
  '(',')','[',']','{','}','X'で作られた文字列が与えられる。'X'には任意のbracketが入る。
  正しいカッコの対応付けがなされているかどうか調べよ。
  'X'の数は高々5個である。
  
[解答]
  'X'の数が少ないので6^5で全探索することが出来る。全探索の方法はDFSや6重ループ、6のべき乗の集合の全探索（ビット全探索の基数を6にしたもの）などがある。
  恐らくDFSが最も考えやすい。'X'が来たらループで6種類を全て試す再帰をすれば良い。
  文字をスタックに詰めていく。閉じカッコが来たときに、既にスタックに文字が詰められていて、かつ対応する開きカッコであれば2度popする。
  その条件を満たさない箇所がある、または最後まで読み込んだときに、スタック内にまだ文字が残っているならinvalid。
  
SRM 628 Div2 Hard 
[問題]
  
[解答]
  ある閉路cに達するパスについて、その頂点数をV_iとする。Π{c in S} (1+V_i) で解けるのではないか？
  コード書きましょう
  
SRM 629 Div2 Easy RectangleCoveringEasy
[問題]
  長方形型の板が長方形型の穴を覆う。それぞれ幅と高さが指定されている。板は90度回転させることが出来る。
  覆うことの出来る条件は、板の幅または高さがstrictlyに穴より大きく、板の幅と高さの両方が穴の長さ以上である必要がある。
  （つまり、穴が見えたり丁度ハマる形でなければ良い）
  与えられた板で穴を覆うことが出来るか？
  
[解答]
  bool ok1 = holeH <= boardH && holeW <= boardW && (holeH < boardH || holeW < boardW);
  swap(holeH, holeW);
  bool ok2 = holeH <= boardH && holeW <= boardW && (holeH < boardH || holeW < boardW);
  return ok1 || ok2 ? 1 : -1;
  
SRM 629 Div2 Med CandyMaking
[問題]
  Σ|desiredWeight[i] - 密度d * containerVolume[i]| を最小化せよ。dは各iに対して共通である。
  
[解答]
  解法1.
  dをxに置き換えて、Σf(x) と置くと、f(x)は凸関数である。凸関数の和は凸関数であるので、dについて三分探索が可能である。
  dの値を求めたら、Σf(d)を計算すれば良い。
  
  解法2.
  d = desiredWeight[i] / containerVolume[i] を総当りして、和が最小となるものを求めると良いようだ。
  参考) http://torus711.hatenablog.com/entry/20140821/1408634808
  
SRM 629 Div2 Hard CandyAddict
[問題]
  一日の給与をX, キャンディ1個の値段をY, 日数をZとする。必ずX >= Yが成立する。
  キャンディを一日1つ消費する。手持ちのキャンディが0個の場合、手持ちのお金を用いてキャンディを出来るだけ購入する。
  Z日後の手持ちのお金はいくらか。クエリは最大100個とする。
  1 <= X, Y, Z <= 10^9
  X >= Y
  クエリ数 <= 100
  
[解答]
  状態を(現在のお金, キャンディの個数)とする。シミュレーションを状態によって分岐してうまく高速化させる。[要追記]
  
SRM 630 Div2 Easy DoubleLetter
[問題]
  文字列Sが与えられる。以下の操作を繰り返し行ったときSを空にすることができるか？
    S中の最も左にある連続する2つの同じ文字を削除する
  N <= 50
  
[解答]
  解法1.
    ループして、S[i] == S[i+1]が成り立つなら、それらを削除し、カウンタと文字列の長さを調整する。
    
  解法2.
    スタックを用意する。
    ループして、スタックが空なら、S[i]を詰める。
    空でないとき、スタックのtop()とS[i]が一致するならスタックからpop()する。そうでなければ、スタックに詰める。
    最終的にスタックが空であるかどうかで判定できる。
    
SRM 630 Div2 Med Egalitarianism3Easy
[問題]
  N頂点の重み付き根付き木がある。頂点の部分集合Sについて、Sに含まれる任意の頂点a, bを繋ぐパスの長さが同じであるものを考える。
  そのような頂点の部分集合のうち最大の頂点数を求めよ。
  N <= 10
  
[解答]
  ワーシャルフロイドして、任意の頂点間の距離を求めておく。
  N <= 10なので、部分集合Sを全探索して、S内の任意頂点a, bを結ぶパスが同じ距離かどうかを調べることが出来る。
  全体で、O(N^3 + 2^N * N^2) で解が求まる。
  
SRM 630 Div2 Hard SuffixArrayDiv2
[問題]
  文字列SのSuffixArrayが与えられる。Sと同じSuffixArrayを持つ文字列で、Sより辞書順で小さい文字列は存在するか？
  N <= 50
  
[解答]
  解法1.[追記出来そうなら追記する]
  文字列Sのどれか一文字を1つ小さくした文字列Tを考える。
  そのようにして作られたTのSAとSのSAで比較して、Sと一致するものがあるかどうかで判定すれば良い。
  Editorialによると証明はあまり簡単ではないらしい。
  
  解法2.[要追記]
  SA(S)と同じSAのうち、最小の文字列を考えてSと比較する。Div1Medと同じ解法となる。
  
SRM 631 Div2 Easy TaroGrid
[問題]
  'W', 'B'で構成されるN*Nのグリッドがある。列で連続する文字が同じであるもののうち最長の長さを求めよ。
  1 <= N <= 50
  
[解答]
  各列について、行の始点と終点を決め、その間をループして最大値を求める。O(N^4)
  
SRM 631 Div2 Med CatsOnTheLineDiv2
[問題]
  P[i]に猫がC[i]匹配置されている。各々の猫は座標xからx-1, x, x+1の何れかに移動できる。
  T秒の移動によって、各位置に高々1匹の猫が存在するような移動の仕方はあり得るか？
  1 <= N <= 50
  0 <= T <= 1000
  
[解答]
  
SRM 631 Div2 Hard TaroCoins
[問題]
  非負整数Kに対して、2^Kの値を持つコインを各々2枚ずつ持っている。
  正の整数Nを持っているコインで表す方法の数を答えよ。
  1 <= N <= 10^18
  
[解答]
  2のべき乗のコインを持っているので、ビットで考える。
  状態を(現在のビットの桁, 繰り上がりがあるか)としてDPすれば良い。
  i桁目のビットが立っているとき
    dp[i+1][0] = dp[i][0] + dp[i][1]  // 「2^iを使う」 + 「2^(i-1)を2枚使う」
    dp[i+1][1] = dp[i][1]             // 「2^(i-1)を2枚使い、2^iを2枚用いて次の桁に繰り越す」
    
  i桁目のビットが立っていないとき
    dp[i+1][0] = dp[i][0]             // 「コインを使わない（繰り越しがあってはならない）」
    dp[i+1][1] = dp[i][0] + dp[i][1]  // 「2^iを2枚用いて繰り越す」+「2^iを1枚と2^(i-1)2枚の繰り越しで次の桁に繰り越す」
  
  初期条件 dp[0][0] = 1 として、Nのすべてのビットを見るまでDPすれば良い。
  
SRM 632 Div2 Easy RunningAroundPark
[問題]
  アリスがトラックを走る。目印として1周の間に1〜Nの番号のついた木が立っている。
  走り抜けたときに見た一部の木の番号が順にA[]で与えられるので、アリスは少なくとも何周走ったかを答えよ。
  
[解答]
  A[i] >= A[i+1] という関係をカウントし、1を足す。
  
SRM 632 Div2 Med PotentialGeometricSequence
[問題]
  解き直す
  
[解答]
  等差数列をカウントする[追記せよ]
  
SRM 632 Div2 Hard GoodSubsets
[問題]
  要素値の重複を含む整数列D[]について、積がgoodValueに一致するような空でない部分集合の数を答えよ。(MOD10^9+7)
  1 <= goodValue <= 2 * 10^9
  1 <= N <= 100
  1 <= D[i] <= 2 * 10^9
  
[解答]
  状態(i番目, 現在の積)としてメモ化再帰する。割り切れるなら割る場合も考慮して、割らない場合と一緒に足しあわせていく。
  2 * 10^9 以下のうちで約数の数が最大の合成数は1396755360であり、その数は1536個である。
  よって、状態数は高々 101 * 1536 であるので map などを用いてメモ化再帰することで解が求まる。
  
  参考) Highly Composite Numbers
  https://en.wikipedia.org/wiki/Highly_composite_number
  以下のサイトはtxtで検索が可能。
  http://wwwhomes.uni-bielefeld.de/achim/highly.txt

  
SRM 633 Div2 Easy Target
[問題]
  サイズNに対して、以下のような図形を生成せよ。
Ex: N = 9 の図形
#########
#       #
# ##### #
# #   # #
# # # # #
# #   # #
# ##### #
#       #
#########
  
[解答]
  解法1.（愚直に描画する方法）
  N*Nの' 'のグリッドに、左上端から4回回転して一周分'#'で塗りつぶす。
  左上端に正確に戻ったら x += 2, y += 2して、同様の作業を繰り返すようにして解く。
  
  解法2.（よりエレガントな方法）
  res[i][j] = max(abs(i-n/2), abs(j-n/2)) % 2 ? ' ' : '#';
  対称になるとは、中心からの距離(abs)を取ること。
  各列、各行変化しないのはi, jのmaxを取ることで満たせる。AOJにも類題がある。
  
SRM 633 Div2 Med Jumping
[問題]
  XY次元平面上を、順にA[i](0<=i<=N-1)の値だけジャンプすることが出来る。
  N回のジャンプで、原点から丁度(x, y)まで移動することは出来るか？
  1 <= A[i] <= 50
  -1000 <= x, y <= 1000
  
[解答]
  原点と(x, y)を繋いだ線分とジャンプの各軌跡による線分とを合わせてN+1個の線分を用いて以下の何れかの条件を満たせるか確かめれば良い。
    1. （単純とは限らない）多角形を生成できるか
    2. 原点と(x, y)との距離が他の線分の大きさの和で表せるか。
  1, 2を合わせて、N+1個の線分の最大長 * 2 <= N+1個の線分の長さの和 かどうかを調べれば良い。
  
SRM 633 Div2 Hard GCDLCMEasy
[問題]
  K要素のA[], B[], G[], L[]が与えられる。以下の2条件が全てのiに対して成り立つようなN個の要素を持つ数列x[]が存在するかどうか判定せよ。
    1. GCD(x[A[i]], x[B[i]]) = G[i]
    2. LCM(x[A[i]], x[B[i]]) = L[i]
  1 <= N <= 500
  1 <= K <= 500
  0 <= A[i], B[i] <= N-1
  1 <= G[i], L[i] <= 10000
  
[解答]
  与えられている式から、A[i], B[i]に従属な関係があるので、頂点をx[i]の添字(A[i]やB[i])として無向グラフに変換することができる。
  すると、従属な関係にある連結成分が幾つかできる。グラフは全体で連結とは限らない。
  よって、各連結成分に対して、与えられている式を満たすx[]が存在するかどうかを調べれば良い。
  LCMの値が10000以下であることから、任意のiに対して、1<=x[i]<=10000と限定できる。
  あるaに対して、x[a]の値を決め打ちすると、aを成分に含むグラフの各頂点の値が深さ優先探索で定まっていき、同時に矛盾するかどうかも分かる。
  つまりaと隣接する頂点bに対して、x[b] = G * L / x[a] として x[b] が定まり、
  同時に、L % x[a] == 0, LCM(x[a], x[b]) = L, GCD(x[a], x[b]) = G の条件で矛盾判定ができる。
  全ての連結成分に対して、この探索を行う。計算量は 10000 * (各連結成分の頂点数 + 各連結成分の辺の数) = 10000 * (V + E) <= 10000 * 1000 <= 10^7
  
SRM 634 Div2 Easy MountainRanges
[問題]
  A[]で山脈の高さが与えられる。隣接する山より高い山をpeakとする。
  peakの数を数えよ。
  
[解答]
  左端と右端は隣接する山は1つのみ。他は2つあるので、ループで数えれば良い。
  
SRM 634 Div2 Med ShoppingSurveyDiv2
[問題]
  M個の品物がある。品物iがs[i]人に購入されたことが分かっている。各人は一つの品物につき高々1個まで購入できる。
  すべての品物を購入した人数の最小数を答えよ。
  1 <= N, M <= 100
  0 <= s[i] <= N
  
[解答]
  できるだけ購入した数が特定の人に偏らないようにしたい。
  購入者に対して購入した品物の数を配列で持つ。M種類の品物それぞれ売れた数s[i]が分かっているので、
  周期Nでそれらを1個ずつ購入させていくシミュレートをする。計算量はO(M*s[i])
  
SRM 634 Div2 Hard SpecialStrings
[問題]
  '0', '1'で構成された文字列がある。文字列がspecialであるとは、文字列をSとおいたとき、
  任意の位置での分割を考慮した S = UV について必ず辞書順で U < V が成立することを言う。
  文字列Sが与えられる。Sはspecialであることが保証されている。
  Sの次に辞書順最小な文字列のうち、specialな文字列を答えよ。そのような文字列が存在しない場合は空文字列を示せ。
  1 <= N <= 50
  
[解答]
  Sの右から初めの'0'を見つけてそれを'1'とする。この文字列はspecialである。
  '1'に変更した位置から後ろの文字列を最小化しよう。
  この文字列をVとすると、Vの左から'1'を'0'としてみたとき、文字列がspecialかどうか判定する。
  これを繰り返していけば良い。O(N+N^2)
  
  以下、唐突に思考過程を書き下します。
  ------------------------------------------------------------------------------------------------------------------------
  いかにして問題をとくか (G.Polya) P.38
  よい考えを探すこと
  Q. どこから出発したらよいか。
    問題の主な部分の考察から出発しなければならない。
    これらの部分がはっきりと並べられ、前にしておいたことのある仕事が役に立ち記憶が役立ちそうな所で手を付ければ良い。
  ------------------------------------------------------------------------------------------------------------------------
  前の仕事が役立つ場所 -> DPや貪欲の初期条件を考えるようなところから考え始める
  
  以下、S = UV とおいて考える。
  1. 末尾は'1'である。
     V="0"であるときを考える。
     Uに'1'を含むならば明らかにU>Vであるし、Uは'0'のみを含む場合でも、U>=Vである。
     
  2. 末尾'1'が確定したので、VよりUの方が小さいためには、Uの先頭は'0'である必要がある。
     Sはspecialであることが保証されているので、S = "0...1" という形である。
  
  3. ある文字列がspecialかどうかの判定を愚直に行うものとする。
     できるだけ小さい文字列について、それがspecialかどうかを判定していきたい。
     よって、右から文字列をいじっていく。ひとまず、はじめのi=N-2のときを考えてみる。
     
     S = "0...x1" (i=N-2) のとき
     a. x = '0' のとき
       x = '1'と変更したとき、より左側の分割において必ず U < V が成立するので、この文字列はspecialである。
       また、i=N-2の場合についてのみ考えているので、Sの次に辞書順最小でもある。
       
     b. x = '1' のとき
       何も出来ることはない。
     
     このような調子で、任意の位置の分割のときも考えてみることにしよう。
     
     S = "0...x...1" (0 < i <= N-2)のとき
     a. x = '0' のとき
       x = '1'と変更したとき、この文字列を S' = U' V' とおく。より左側の S'の分割において必ず U' < V' が成立するので、この文字列はspecialである。
       しかし、S'はSの次に辞書順最小かどうかはわからない。xの位置より後ろをV'とすると、V'をより小さく出来る可能性があるからである。
       つまり、S < Ans <= S' となる Ans を見つける必要がある。Ansのxの位置より後ろの文字列を改めてV'とし、その前の文字列をU'と置く。
       どのようにspecialが成立するための最小のV'を見つければよいか。V'の左から文字をいじっていくと良い。
       もし右からいじってしまうと、右をいじってしまったせいでより左の'1'を'0'にする可能性を失いかねない。
       よって、V'の左から文字をいじる。具体的には、左から'1'を'0'にしたとき、specialなら'0'に変更して次へ。
       specialとならないなら、'1'に戻して、次へ。としていく。
       U'についても、Sの右から変更しているので、より分割の位置を左にしたときより小さいことが確定している。
       よって、AnsはSの次に辞書順最小であるspecialな文字列である。
       
     b. x = '1' のとき
       こちらの場合は、もはや考える必要がない。
    
SRM 635 Div2 Easy IdentifyingWood
[問題]
  サイズN, Mの文字列S, Tが与えられる。TはSの部分列(consecutiveとは限らない)となるか。
  1 <= N, M <= 10
  
[解答]
  二重ループで、S[i] == T[pos]が一致したらpos++とすることを繰り返す。
  pos >= T.size() となるかどうかを判定すれば良い。
  
SRM 635 Div2 Med QuadraticLaw
[問題]
  T秒遅れたらT^2秒速く授業を終了させなければならない。授業時間は0秒以上D秒以下である。
  最大のTを求めよ。
  1 <= D <= 10^18
  
[解答]
  T + T * T <= D を満たすかどうかで二分探索すると良い。
  上式でオーバーフローしないように式を除算に変形させるか、L=0, R=sqrt(D)+10 などとして始めると良い。
  
SRM 635 Div2 Hard LonglongestPathTree
[問題]
  N頂点の重み付き木が与えられる。一つの辺を取り除き、木を1つまたは2つに分割する。
  取り除いた木を付け替えて分割した木を再度接着し、1つの木とする。
  出来た木の最大の直径を求めよ。元の木と同じ木が最大となる場合もある。
  2 <= N <= 2000
  #(A[]), #(B[]), #(L[]) = N-1
  1 <= L[i] <= 10^9
  
[解答]
  木の直径は任意の頂点からDFSして到達した最遠点から、再度DFSすることで求めることが出来る。
  取り除く枝を総当りして、その度に分割された2つの木それぞれで木の直径を求める。
  2つの木の直径と取り除いた木の重みの和の最大値を求めれば良い。
  木を分割するときは、取り除く枝を使わないものとして登録しておいて、
  その枝の両端点からDFSを開始すれば分割した木のグラフを用意する必要はない。
  O(E^2)で解を求めることが出来る。
  
SRM 636 Div2 Easy GameOfStones
[問題]
  複数の積石がA[]で与えられる。一つの積石から2つの石を取り除いて、それらを他の1つの積石に乗せることが出来る。
  全ての積石を同じ個数ずつにするための最小数を答えよ。それが出来ない場合は-1を示せ。
  1 <= N <= 100
  
[解答]
  解法1.
  A[]をソートする。この状態でA[0]とA.back()の値が等しいかみて、同じ個数ずつかどうかを判定する。
  A.back()から2個だけをA[0]に移す。
  このとき、A[0]とA.back()の位置が逆転してしまうようなことがあれば、それ以降は同じ操作の繰り返しとなるので-1である。
  以上の手順を無限ループで繰り返せば良い。
  
  解法2.
  まず平等に分配できる個数があるか調べる。総和を配列のサイズで割った余りを見れば良い。
  次に、各個数は平等に分配した時の個数との差分をみる。これが2で割り切れないなら、丁度平等な数にすることは出来ない。
  差分が2で割り切れるなら、各差分の総和が最小操作回数の2倍(取る、置くをそれぞれカウントしている)となる。
  よって、差分の総和を2で割れば答えとなる。
  
  解法3.
  以上のような解法が思いつかなければBFSすればよい。
  
SRM 636 Div2 Med SortishDiv2
[問題]
  数列のsortednessとは、i < j に対して S[i] < S[j] である関係の数である。
  1〜Nの順列によって作られる数列S[]がある。S[]のうちある部分は値がわからず、代わりに0となっている。
  S[]のsortednessがKである場合の数を答えよ。
  0 <= K <= 10^9
  1 <= N <= 100
  0 <= S[]中の0の数 <= 5
  
[解答]
  1〜Nの順列で、含まれていない物の数を数える。S[]中0の数が5個以下なので、最大5個である。
  この5個をnext_permutationでS[]の0の部分にあてがう。その中で2重ループをして S[i] < S[j] の数を数え上げれば良い。
  また、N <= 100 なので K <= 10^9 はハッタリである。
  特に条件分岐する必要はないが、K > 10^4 / 2 = 5000 において、場合の数は0となる。
  
SRM 636 Div2 Hard ChocolateDividingHard
[問題]
  N*Mの板チョコを縦4分割、横4分割で16個の長方形に分割する。
  板チョコの各マスには質が0〜9の値で定義されている。
  板チョコの部分長方形について、その質は長方形内のマスの数字の和で定義される。
  分割した長方形のうち質が最小のものを最大化した値を求めよ。
  4 <= N, M <= 75
  
[解答]
  横に割る分割を全探索する。これはO(N^3)で出来る。
  最小の質をXとおくと、縦に割る分割は、横の分割で割った4つの長方形について各々がX以上となるまで足していけば良い。
  4つの部分がそれぞれX以上となったら、丁度その場所で縦の分割を入れる形になる。
  縦方向の和を事前計算できるようにしておけば、この処理はO(M)で行うことが出来る。
  最小の質Xを最大化したいので、これを二分探索で行う。O(N^3 * M log Xmax) で、ぎりぎり解が求まる。
  
SRM 637 Div2 Easy GreaterGameDiv2
[問題]
  i について、A[i] > B[i] であるとき、勝点1である。それ以外のとき勝点0である。
  0<=i<=N-1について考えたとき、勝点の総和を求めよ。
  
[解答]
  rep(i, A.size()) ans += A[i] > B[i];
  
SRM 637 Div2 Med PathGameDiv2
[問題]
  '#', '.'で構成された、縦2、横Mのサイズのグリッドがある。'#'は通れないマスで、'.'は通れるマスである。
  プレイヤーは辺を共有するマスへ移動することができる。初期状態でグリッドのx = 0の位置からx = M-1の位置まで移動できるようになっている。
  x座標が0からM-1まで移動できるパスを1つ以上持つように、'.'のマスを'#'で埋めたとき、埋めることの出来る数の最大数を答えよ。
  
[解答]
  全体のマスの数 - 元の'#'の数 - 最短経路のマスの数 が答えである。
  最短経路を求める方法には以下の二通りがある。
    1. x=0として、y=0またはy=1からスタートして、xの正方向に真っすぐ進み、'#'に突き当たったらy座標を切り替える。
    2. BFSする。
  
SRM 637 Div2 Hard ConnectingGameDiv2
[問題]
  英数字で構成されたN*Mのグリッドが与えられる。
  辺を共有するマスが同じ文字で表されていたら、それらは一つの領域をなすという。
  先手が防衛で、後手が攻撃側である。攻撃側はグリッド最上部から最下部に移動を試みる。
  攻撃側は赤く塗られた領域を通過することは出来ない。防衛側が、任意の領域を赤く塗ることが出来る。
  赤く塗るためのコストは、その領域のマスの数に対応する。最小コストで攻撃側の最下部への移動を阻止し、その時のコストを答えよ。
  1 <= N, M <= 50
  
[解答]
  平面グラフの最小カットは、双対グラフの最短経路に一致する。よって、グリッドを横方向に横切る最短経路のコストを求めれば良い。
  各領域の塗るコストをBFSやDFSなどで求め、対応する頂点を決める。グラフは、領域がマスの頂点を共有するとき(即ち隣接8方向)辺を張るようにすればよい。
  改めて双対グラフの最短路であることに注意すると、元の平面グラフが最上端から最下端まで到達するのに対して、
  こちらは最左端から最右端まで到達するための最小コストをダイクストラで求めればよい。
  
SRM 638 Div2 Easy NamingConvention
[問題]
  変数名をSnakeCaseからCamelCaseに変換したい。
  ある文字列Sが与えられる。Sは英小文字と'_'との連結で作られた変数名(SnakeCase)である。
  この文字列を英小文字から始まり'_'を区切りにして、先頭のみ大文字とする変数名(CamelCase)に変換せよ。
  
[解答]
  '_'が来たら、次の文字はCapitalizeするというフラグを持ってループを回すと良い。
  
SRM 638 Div2 Med NarrowPassage2Easy
[問題]
  N要素の数列A[]の隣接する2要素の和がX以内なら、その位置を交換することが出来る。
  A[]の各要素を値に限らず区別しているとき、0回以上の任意回数の交換によって生成できる数列のパターン数を求めよ。
  1 <= N <= 6
  
[解答]
  状態に数列を持ち、隣接する要素の和がX以内なら交換できるとしてBFSすれば良い。
  
SRM 638 Div2 Hard CandleTimerEasy
[問題]
  各枝に重みがついた木がA[],B[],len[]で与えられる。任意個数の葉に点火することが出来る。
  火は1秒ごとに1だけ進み、節点を境に各枝に勢いをそのままにして伝播する。火が合成して勢いを増すようなことはない。
  枝の両端点から火が進行した場合、片方のみから火が進行する場合の倍のスピードで進行する。
  点火の作業は、点火する葉に対して同時に行われる。点火を開始してから、火が木を燃やし尽くすまでの時間を計りたい。
  任意個数の葉への点火を試すことによって計ることの出来る時間のパターン数を答えよ。
  1 <= |A| = |B| <= 19
  1 <= len[i] <= 1000
  
[解答]
  予め任意の頂点u, v間の距離をワーシャルフロイド法を用いて求めておく。
  頂点数は N = |A| + 1 であり、N <= 20 である。葉の数L <= N なので、使う葉を全探索(O(2^N))する。
  各枝を総当り(O(N))して、最も焼却の遅い枝を見つけてその焼却までの時間をsetに詰める方針を取る。
  Sを使う葉の頂点集合とし、対象の枝の端点をa, bとおく。頂点u, v∈Sに対して、dist(u, a), dist(v, b) を考え、
  それぞれdistが最小となるu', v'を見つける。(u',v'は独立に処理して良いのでO(N))
  u', v'が異なるとき　  max(mindist(u'), mindist(v')) + (u'v'間の枝の長さ) - abs(mindist(u') - mindist(v'))) / 2.0 が、枝を焼却するまでの時間となる。
  u', v'が一致するとき  max(mindist(u'), mindist(v')) が、枝を焼却するまでの時間となる。
  一致するときの方が少ない時間で済むので、mindist(u'), mindist(v')が同一でもu', v'が一致する場合があるなら、一致する場合を優先する。(O(1))
  全ての枝について焼却時間を求め、その最大値が木を焼却する時間であるので、この時間のパターン数をsetに詰めて求めれば良い。
  全体でO(2^N * N^2)で解が求まる。(2^20) * (20 * 20) <= 419430400 < 5 * 10^8 より、ぎりぎり間に合う。
  
SRM 639 Div2 Easy ElectronicPetEasy
[問題]
  pet1には、時刻st1から、周期p1で、t1回餌を与える。
  pet2には、時刻st2から、周期p2で、t2回餌を与える。
  餌を与える時間が重複するかどうか判定せよ。
  1 <= st1, p1, t1, st2, p2, t2 <= 1000
  
[解答]
  解法1.
  t1, t2 <= 1000 と小さいので、二重ループで回数を回し、st1 + p1 * i == st2 + p2 * j を判定すれば良い。O(t1*t2)
  
  解法2.
  片方の時刻を(unordered_)setなどに記録しておいて、もう片方がそれを満たすか調べる。
  ループを2回書いて、O(max(t1, t2))で解が求まる。
  
SRM 639 Div2 Med AliceGameEasy
[問題]
  2人でゲームをしている。i(>=1)試合目に勝ったほうがi点得られる。
  整数x, yが与えられる。ゲームの状態が(先手, 後手) = (x点, y点)となることはあり得るか。
  あり得るならば、その過程で 先手 = x点 となるために勝つべき最小の試合数を答えよ。
  0 <= x, y <= 10^12
  
[解答]
  K試合で、二人の合計点がx+yであるとすると、K*(K+1) = x+y が成立するかどうか調べれば良い。
  Kを10^6程度まで全探索すればよい。
  上式を満たすようなKがあるなら、集合{1,2,...,K}のうち、どの部分集合の値の和をxとすれば、部分集合の要素数を最小にできるか考える。
  これは値の大きい方から選んでいくのが最適で、部分集合の要素数を最小にすることが出来る。
  よって、xからKに近い値からできるだけ引いていき、引くことの出来た回数を数えれば良い。
  
SRM 639 Div2 Hard BoardFoldingDiv2
[問題]
  
[解答]
  Editorialを読もう！
  
SRM 640 Div2 Easy ChristmasTreeDecorationDiv2
[問題]
  木が与えられる。各頂点に色が与えられている。枝の両端点の色が異なる数を答えよ。
  
[解答]
  rep(i, x.size()) ans += col[x[i]-1] != col[y[i]-1];
  
SRM 640 Div2 Med NumberGameAgain
[問題]
  x = 1 を1回以上K-1回以下の回数だけ、2*xまたは2*x+1に置き換える。例えば、1,2,5,11,22,...というように遷移する。
  つまり、高さKの完全二分木を考えて、根を1として部分木に遷移していく。
  ただし、xがA[]で指定された数字、または指定された数字から置き換えることのできる数字に遷移してはならない。
  x = 1から遷移することの出来る場合の数を答えよ。
  2 <= K <= 40
  0 <= |A| <= 20
  
[解答]
  A[]で禁止される部分木のうち、できるだけ根に近いdisjointな部分木のみを考慮し、重複を防ぐ。
  これはA[]をソートして、大きい数を除算していったとき、小さい数に一致するか調べれば良い。
  二分木なので葉の方向に遷移する方法は2通りあるが、根の方向に遷移する方法は1通りであるため、このような方法が適用できる。
  重複を取り除いた数列A'[]に対してその各要素をxとすると、全体の木の頂点数からdisjointな部分木の頂点数を引いて、
  (2^K - 1) - Σ(2^(K - (int)log2(x)) - 1) - 1 が解となる。1回以上の遷移が必要なことに注意する。
  2のべき乗であるが、pow関数(type generic)やpowl関数を用いても良いが、1LL<<xとするのもよい。
  
SRM 640 Div2 Hard TwoNumberGroupsEasy
[問題]
  multisetA, multisetB が与えられる。A[i]がnumA[i]個, B[i]がnumB[i]個である。
  multisetの距離とは、各要素の数の差の和をとったものとして定義される。
  また、multisetに対して、modを取る事ができる。
  例えば、multisetA に対して、mod Mを取ると、各要素の個数は、A[i] % Mの値が一致する全てのiについて、numA[i]の和を取ったものになる。
  multisetA % MとmultisetB % Mの距離を最小化するようなM(Mは1より大きい整数)を選択し、そのときの距離を答えよ。
  1 <= |A|, |B| <= 10
  1 <= A[i], B[i] <= 10^9
  1 <= numA, numB <= 10^5
  
[解答]
  |A|, |B| <= 10 と小さいので、multisetA % M, multisetB % Mの演算は容易である。
  よって、適切なMを選択することが問題となる。Mの値を絞り込むことは出来ないか考える。
  ここで、A[i], B[j]が重複するときはどのようなMを選んだときかを考える。
  言い換えると、A[i] ≡ B[j] (mod M) <=> A[i] - B[j] ≡ 0 (mod M) が成立するようなMを選べば良い。
  M が A[i] - B[j] の約数であれば、A[i] - B[j] ≡ 0 (mod M) が成立する。
  A[i] - B[j] は負になる可能性もあるが、M > 1なので、|A[i] - B[j]| ≡ 0 (mod M) となるMを考えても同じである。
  よって、|A[i]-B[i]|の全ての約数 (任意のi, j, 0<=i<|A|, 0<=j<|B|) がMの候補と鳴る。
  約数の数であるが、10^9以下の最大の約数の数を持つ合成数は735134400であり、約数の数は1344である。（cf. Highly Composite Numbers）
  よって、計算量を100*1344で抑えて解を求めることが出来る。
  
SRM 641 Div2 Easy BuyingTshirts
[問題]
  Tシャツの値段は一律T円で与えられる。A, Bがそれぞれi日目のはじめに得られる給料がA[], B[]で与えられる。
  Tシャツを購入できるだけのお金を手に入れたら即座に1日1枚購入する。
  AとBが購入に店を訪れる日が重なる回数を求めよ。
  
[解答]
  給料を足してループして一枚購入できるなら手持ち金から引いて、A, Bそれぞれ引いた場合はカウントする。
  
SRM 641 Div2 Med TrianglesContainOriginEasy
[問題]
  二次元平面上の格子点上にN個の点の集合が与えられる。
  N個の点から3つの異なる点を選び、それらによって作られる三角形のうち、原点をstrictlyに内部に含むものの数を答えよ。
  3 <= N <= 50
  
[解答]
  3重ループで3点を選ぶ。3点から任意の2点を選び、2点で作るベクトルから見て時計回りの位置に原点が存在するかどうかを判定すれば良い。
  時計回りかどうかは、(u, v)✕(u, origin) < 0 かどうかで判定できる。
  
SRM 641 Div2 Hard ShufflingCardsDiv2
[問題]
  1〜2Nの番号が書かれている順に並んだ2N枚のカードがある。
  これをを2分割して、それぞれシャッフルする。それらを交互に重ね合わせる。この処理を2回行う。
  数列P[]は1〜2*Nのpermutationである。これは上の操作によって生成できる数列かどうか答えよ。
  
[解答]
  落ち着いてるときやれば解ける筈！
  
SRM 642 Div2 Easy ForgetfulAddition
[問題]
  数字で構成された文字列Sが与えられる。
  これを任意の位置で二分割して、それらの数値としての和を取った時の最小値を答えよ。
  
[解答]
  ループで分割位置を決めて、substr(), std::stoi()などを活用して和を取り最小化する。
  
SRM 642 Div2 Med LightSwitchingPuzzle
[問題]
  1〜N番の番号のついた一列に並んだスイッチとライトがある。i番のスイッチはiの倍数番号の全てのライトの点灯・消灯を切り替えることが出来る。
  'Y'を点灯、'N'を消灯として、現在の状態が文字列Sで与えられる。全て消灯とするためにスイッチを押す回数の最小値を答えよ。
  1 <= N <= 1000
  
[解答]
  左から順にスイッチを見て行くとき、点灯しているライトと同じ番号のスイッチを押さずに通りすぎた場合、
  それより後ろの番号で通り過ぎた番号のライトを点灯させる事はできない。また、スイッチを2度以上押すのは無駄である。
  以上より、左から順にi番目のライトが点灯していたらそのスイッチを1度だけ押すという操作をしていくのが最適である。
  各番号でスイッチを押してライトの点灯、消灯が逆転するシミュレーションを行えばO(N^2)で解くことが出来る。
  
SRM 642 Div2 Hard TallShoes
[問題]
  無向グラフが与えられる。各辺には、辺を通過するためにの靴の高さが最高H[i]までという制限が与えられている。
  各辺高々1度限り、高さ制限をKだけ上げることが出来る。そのためにはコストK^2だけかかる。
  予算Bを用いて頂点0からN-1まで移動するための、靴の高さの最大値を求めよ。
  2 <= N <= 50
  0 <= H[i] <= 10^6
  0 <= B <= 10^15
  
[解答]
  靴の高さを二分探索する。靴の高さをHeightとして、グラフ上を頂点0からN-1まで移動できるかダイクストラを用いて判定する。
  ダイクストラは、頂点iでの予算D[i]を最大化するようにして行う。
  
SRM 643 Div2 Easy TheKingsArmyDiv2
[問題]
  隊員がN*Mグリッド上に整列している。各隊員の士気が'H'または'S'で与えられる。
  自分が'H'で、かつ辺を共有するマスにいる隊員の一人が'H'であるとき、2人の隊員たちと辺を共有する全ての隊員の士気が'H'となる。
  また、報酬を与えることで士気が'S'である隊員を'H'とすることが出来る。
  現在の隊員の士気の状態が与えられたとき、全ての隊員の士気が'H'となるために報酬を与えなければならない隊員数を最小化せよ。
  3 <= N, M <= 50
  
[解答]
  少なくとも1つ辺を共有する2人が'H'であれば全員'H'とすることが出来る。
  よって、全員'S'の場合は2、'H'が隣接しない場合は1、'H'が隣接する箇所がある場合は0とすれば良い。
  
SRM 643 Div2 Med TheKingsFactorization
[問題]
  巨大な整数Nと、Nの素因数のリストを昇順に並べたものの奇数番目の要素のみで出来たリストが与えられる。
  Nを素因数分解したリストの昇順ソートしたものを求めよ。
  N <= 10^18
  
[解答]
  √N <= 10^9 なので、通常の素因数分解の方法ではTLEする。
  奇数番目のリストであるので、Nの素因数を昇順に並べたときの最後の3要素(a1<=a2<=a3)のうち、a1とa3、またはa2の素因数が分かっていることになる。
  先ず、与えられたリストの各要素でNを除算しておく。これをN'とおく。
  リストからa1, a3が分かっている場合、N'をa1以下の値までの素因数分解を試すことが出来れば、N'を除算して残った値がa2に一致する。
  a1は、Nの3乗根<=10^6以内に抑えることが出来るので素因数分解を試すことが出来る。
  リストからa2が分かっている場合、a1のみ知ることが出来ればa3はN'を除算していった余りに一致する。a1<=10^6より、これは可能である。
  よって、Nを与えられたリストで除算したあと、10^6以下において素因数分解を試せばO(Nの3乗根)で解が求まる。
  
SRM 643 Div2 Hard TheKingsTree
[問題]
  N頂点の根付き木がある。各頂点に赤または緑の色を塗る。
  ある頂点vの色を塗るコストは、その頂点も含む部分木の頂点のうち頂点vと同じ色の数だけ掛かる。
  すべての頂点に色を塗るためのコストを最小化せよ。
  1 <= N <= 50
  
[解答]
  dp[頂点番号][これまで赤色を塗った数][これまで緑色を塗った数] := 最小コスト
  としてDPする。[要追記]
  
SRM 644 Div2 Easy OkonomiyakiShop
[問題]
  数列O[]から2つの値を選び、その差がK以下であるような選び方の総数を求めよ。
  N <= 50
  
[解答]
  2重ループで該当するパターンを調べ上げればよい。
  ループ変数を 0 <= i < j < N として、abs(O[i] - O[j]) <= K となる数をカウントする。
  
SRM 644 Div2 Med LostCharacter
[問題]
  英小文字で構成された文字列集合L(要素数N)が与えられる。各文字列は一部'?'を含む。'?'には任意の文字が充てがわれる。
  文字列をソートした時に、各文字列に対して最小のindexで作るリストがある。
  例えば、{"a","a","b","b","c","c"}ならば、{0,0,2,2,4,4}となる。
  Lをソートしたとき、各文字列に対して最小のindexのリストを作れ。
  N <= 50
  
[解答]
  ある文字列iの全ての'?'を'a'とし、他の文字列の'?'は'z'とする。
  これを全ての文字列に対して試せば良い。
  
SRM 644 Div2 Hard TreeCutting
[問題]
  一部の頂点に値が与えられているN頂点の木が与えられる。この木を森に分割する。
  分割した各々の木において、値の付随する頂点はただ一つであり、木はちょうどその値の数だけの頂点をもつ。
  このような操作が可能かどうか調べよ。
  1 <= N <= 50
  
[解答]
  木を森に分割するとき、切断することになる枝が定まる。
  もともとある木から部分木を取り除いていくとかんがえられるので、1個取り除けば、木は2個になり、2個取り除いて、木は3個...
  つまり、切断することになる枝の数 = 切断によって出来た木の数 - 1 = 値の付随する頂点の数 - 1 となる。
  また、切断する枝の一方はただ一つの値つき頂点を含み、他方は1個以上の値つき頂点を含むようになる。
  よって切断する枝を全探索して、両側の木の各々において 木のサイズ = 頂点に付随する値の和 が成り立つかどうか調べる。
  切断する枝の一方の木がただ一つの値つき頂点を含むことから、上式が成立する枝の数と 値の付随する頂点の数 - 1 とが一致するかどうかを調べれば良い。
  木のサイズ tsize[v] = 1 + Σ DFS(部分木)
  木の値の和 nsum[v] = (num[v] is empty ? 0 : num[v]) + Σ DFS(部分木)
  とすれば、それぞれ同時に求めることが出来る。
  
SRM 645 Div2 Easy BacteriesColony
[問題]
  N匹のバクテリアが一列に並んでいる。各々サイズがS[i]である。
    1. i番目のバクテリアが、両側に自分よりstrictlyに大きなバクテリアに挟まれていたら次のターンまでにサイズが1大きくなる。
    2. i番目のバクテリアが、両側に自分よりstrictlyに小さなバクテリアに挟まれていたら次のターンまでにサイズが1小さくなる。
  定常状態になったときの各バクテリアのサイズを求めよ。
  3 <= N <= 50
  
[解答]
  現在のサイズの状態をcurr[]とし、次のターン開始時点の状態をnext[]とする。
  無限ループで題意の通りシミュレーションする。next = curr として、if(1が成立) next[i] ++; if(2が成立) next[i] --; としていく。
  curr == next が成り立つなら、curr[] が答えとなる。
  
SRM 645 Div2 Med ConnectingCars
[問題]
  一つの線路上に位置P[i], 長さL[i]のN台の車両がある。各車両を左右に動かすことが出来る。
  N台を連結するために各車両を動かす距離の総和を最小化せよ。
  2 <= N <= 50
  
[解答]
  車両を位置でソートする。N/2番目の車両を固定して、各車両をN/2番目の車両に向かって進行させれば良い。
  車両i, j(i≠j)の距離を計っておくと楽。dist[i][j] = dist[j][i] = P[j] - P[i] + Σ{i<=k<j} L[k] で求まる。
  
SRM 645 Div2 Hard JanuszInTheCasino
[問題]
  平面をM個のフィールドに分ける。N人でゲームをする。1ラウンドの進行は以下のとおり。
    1. 各人がM個のうちどれか一つのフィールドを選ぶ。
    2. M個のフィールドのうち一様にランダムに一つのフィールドが選ばれる。
    3. 選ばれたフィールドを選んだ人間はゲームから追い出される。
  Kラウンド行われる。N人が最適な戦略をとったとき、Kラウンド終了後に一人でも生き残っている確率を求めよ。
  1 <= N <= 10^12
  1 <= M, K <= 50
  
[解答]
  最適戦略は、各ラウンドにおいて各々が出来るだけバラバラのフィールドを選択することである。
  プレイヤー人数をMで割った余りの分だけ、M-余り だけ選択されたフィールドと比べて、選択されたときに抜ける人数が1人多い。
  それを考慮して2通りの遷移をメモ化再帰を行う。（プレイヤー人数が丁度Mで割り切れる場合は確率0となるので特別場合分けをする必要はない）
  状態は(プレイヤー人数, ラウンド数) となる。人数 / M と 人数 / M + 1 の2通りの遷移があるが、
  人数が余り変化しないので、メモ化しておけば処理される再帰の回数は多くても1000回程度で収まる。
  
SRM 646 Div2 Easy TheConsecutiveIntegersDivTwo
[問題]
  数列A[]について、以下の操作を任意回数行うことが出来る。
    要素を一つ選び、1加算するか1減算する。
  数列A[]を適当に並び替えた時、K個以上の連続する数の部分列が作れるためには最小何回操作すればよいか。
  2 <= N <= 47
  1 <= K <= 2
  
[解答]
  K = 1 のときは 0 となる。
  K = 2 のときは、ソートして隣接する数の差+1の最小値を求めれば良い。
  
SRM 646 Div2 Med TheGridDivTwo
[問題]
  無限に広い平面グリッドがある。
  (x[i], y[i]) にブロックが置かれている。1回の操作で辺を共有するマスのうちブロックのないマスに移動できる。
  原点からK回以内に移動できる座標のうち、最大のX座標を求めよ。
  -1000 <= x[i], y[i] <= 1000
  1 <= K <= 1000
  
[解答]
  例えば原点を(1005, 1005)などと決めて、G[2010][2010]のグリッド上をBFSすればよい。
  
SRM 646 Div2 Hard TheFootballDivTwo
[問題]
  リーグ戦が行われている。プレイヤーチームの現在の得点はY点である。
  他のチームの点数について、S[i]点であるチームがC[i]チームである。
  チーム数は、合計で 1 + ΣC[i] である。
  1度の試合で2チームが対戦し、勝った方が3点、負けた方が0点獲得することができる。
  各々のチームについて、残り2試合ずつ行われる予定である。
  残りの試合の組み合わせを任意に決定することができるとき、プレイヤーチームの最高順位(1-origin)を求めよ。
  プレイヤーチームと得点がタイの場合は、プレイヤーはその中で最も良い順位になることができる。
  0 <= Y <= 100000
  1 <= |S| <= 47
  |S| = |C|
  0 <= S[i] <= 100000
  1 <= C[i] <= 100000
  
[解答]
  シミュレーションで解くことができる。以下の様な道筋で解くことができる。
    1. プレイヤーチームは残り2試合とも勝つのが最適なので、Y += 6としておく。初めの順位を1位としておく。
    2. Y + 1 以上のチームについて、プレイヤーチームが勝つことは出来ないので、チームの数だけ順位を繰り下げる。
    3. Y + 1 以上, Y - 6 以下のチームについて、プレイヤーチームとの順位の入れ替わりがないので、高々2度ずつ勝たせる。
       同様に、Y - 3 以下のチームについて、高々1度ずつ勝たせる。
    4. 試合が余っていたら、残り試合数の多い順に1チームずつできるだけ試合させていく。チームの数だけ順位を繰り下げる。
  [(スコア, 残り可能試合数)] という pair<int, int>[] 要素数を他のチーム数として解いた。
  チーム数をTとすると、T <= 4700000 だが、愚直にシミュレートさせてもO(T)なので余裕。
  シミュレートにおける1の加算や減算を計算して与えてやればO(N)になる上、コードも短い。
  
SRM 647 Div2 Easy PeacefulLine
[問題]
  N人の生徒の年齢が与えられる。生徒を一列に並べたいが、同じ年齢の生徒が隣同士となってはならない。
  そのような並び替えは可能か判定せよ。
  N <= 25
  A[i] <= 25
  
[解答]
  隣り合うかどうかで過半数を考えるのは頻出。
  生徒が偶数人居るとき、同じ年齢の生徒が過半数人を占めたときに不可能となる。
  生徒が奇数人居るとき、同じ年齢の生徒が過半数+1人を占めたときに不可能となる。
  まとめて、(生徒の人数 + 1) / 2 より大きい人数を占める同じ年齢の生徒が居れば不可能、それ以外は可能である。
  
SRM 647 Div2 Med TravellingSalesmanEasy
[問題]
  M個の街がある。N回街を訪れる。
  i番目にvisit[i]番目の街を訪れる。city[i]番目の街で、profit[i]の収入を高々1回得ることができる。
  visit[i]やcity[i]は繰り返し現れることがある。
  visit[]を全て順に訪れたとき、収入を最大化せよ。
  N <= 2500
  M <= 100
  
[解答]
  街の番号に対して、profitをvectorに詰めていく。
  それぞれを降順ソートして、上からどこまで使用したかを街の番号ごとに覚えて貪欲していけば良い。
  
SRM 647 Div2 Hard BuildingTowers
[問題]
  
  
[解答]
  解けない時は、Div1Easyが劣化版なので、そちらを先に解いてみると良い。
  Div1Easyを解きましたが、この問題はイマイチ解けません。
  
SRM 648 Div2 Easy KitayutaMart2
[問題]
  i個目の品物は2^(i-1) * K円掛かる。
  予算T以内で何個の品物を購入できるか。
  80 <= K <= 160
  80 <= T <= 163680
  
[解答]
  累乗を計算しておいて、購入する品物の個数を1から10までループさせながら和を取れば良い。
  
SRM 648 Div2 Med Fragile2
[問題]
  自己ループと多重辺がなく、連結とは限らない無向グラフが与えられる。
  グラフから2つのordered-pairの頂点を選んだとき、それらの頂点を取り除くと連結グラフの個数が増えるとき、そのようなペアの数を答えよ。
  N <= 20
  
[解答]
  問題文にarticulation-pairなどと書いてあるので若干騙されるかもしれないが、普通の実装で解ける。
  まずDFSで、連結グラフの数を数える。
  次に、2つの頂点を全探索して再びDFSをする。連結グラフの数が増えていたら、カウントすればよい。
  
SRM 648 Div2 Hard ABC
[問題]
  長さNの文字列Sは、'A','B','C'の3種類で構成される。
  i < j かつ S[i] < S[j] の関係の数が丁度K個存在するような、長さNの文字列Sを一つ求めよ。
  解がない場合はempty stringを出力せよ。
  N <= 30
  K <= N*(N-1)/2
  
[解答]
  文字列からパターン数を求めるような問題では、
    dp[i][覚えるべき状態...] := パターン数
  というようになる。覚えるべき状態には、例えば文字xを使用した数だとか、文字を変更した回数だとかが入る。
  そのようにして、幾つも考えられうる文字列のパターン数を求める。
  
  今回は関係の数が与えられていて、その状態を満たすような文字列であれば何でも許される。
  代表の文字列のみを考えて、パターンを1通りとすると、状態に対してDPの値が一意になる。
  パターン数であれば1で固定であるが、ここに遷移の情報を与えることにする。
    dp[i][状態curr] = 状態prevからcurrへの遷移の情報
  状態prev -> 状態curr に 遷移の情報dp[i][curr]に対応する変位を加えたので、
  状態curr -> 状態prev へは dp[i][curr] に対応する変位を引けば良い。
  
  以上より、
    dp[i][Aの数][Bの数][関係の総数] := 最後に追加した文字
  とすれば、DPの計算結果より代表の文字列を1つ復元できる。
  文字 = 0 を不適と決めておけば、全てのa, b, k において dp[N-1][a][b][k] > 0 が成立しなければ解なしと分かる。
  また、Cの数は i+1-(Aの数+Bの数) である。
  a + b が i+1 を超えないかを調べて、Cの数の存在条件を満たすかのチェックを忘れないようにする。
  
SRM 649 Div2 Easy DecipherabilityEasy
[問題]
  文字列Sがある。Sからただ一文字抜いたとされる文字列Tがある。
  Tが本当にSから一文字抜いた文字列かどうか確かめよ。
  N <= 50
  
[解答]
  文字列Tに対して挿入場所を全探索して、その場所に'a'から'z'の文字の何れかを挿入した文字列とSとを比較する。
  
SRM 649 Div2 Med CartInSupermarketEasy
[問題]
  N個の列をなしたカートがある。一度の操作でカート1台を収納する操作か、カートを2分割する操作が認められる。
  2分割する操作は最大K回だけ行うことができる。
  それぞれのカートのカタマリに対して、いっぺんに操作を行うことができる。
  操作回数を最小化せよ。
  
  1 <= N <= 100
  0 <= K <= 100
  
[解答]
  解法1.
  O(N^2K^2)のメモ化再帰で解く。最大で計算量が10^8となるのでギリギリだが間に合う。
    dp[n][k] := n個のカート, 残りk回分割可能 であるとき、操作回数の最小値
  とする。
  それぞれのカートのカタマリに対して、いっぺんに操作できることに注意して、
    dp[n][k] = min{ 1 + dfs(n-1, k),
                    1 + max(dfs(i, j), dfs(n-i, k-1-j)) (for all i, j) }
  とすれば解を求めることができる。
  
  解法2.
  kmjpさん解 O(KlogK)? [要追記]
  http://kmjp.hatenablog.jp/entry/2015/02/13/1030
  
SRM 649 Div2 Hard XorSequenceEasy
[問題]
  
  
[解答]
  

SRM 650 Div2 Easy TaroJiroDividing
[問題]
  はじめに数Xを決める。操作は以下のように行われる。
    1. 数Xを紙に書く。
    2. Xが偶数のとき、Xを2で割って1に戻る。Xが奇数のとき、操作を終了する。
  数Xとして、AとBを決めて、それぞれで操作を行った。操作で紙に書かれた数が同じであるものの数を数えよ。
  1 <= A, B <= 10^9
  
[解答]
  log2(A), log2(B) は 高々30に収まるので小さい。よって、2で繰り返し割った値を配列に詰めて、
  2つの配列中の同じ値の数を数え上げれば良い。
  
SRM 650 Div2 Med TaroFillingAStringDiv2
[問題]
  文字列の醜さとは、同じ文字が連続している場合の数に対応する。
  文字列Sが'A','B','?'で作られる。'?'には'A','B'のどちらをいれても良い。
  文字列Sの醜さを最小化せよ。
  |S| <= 50
  
[解答]
  解法1.
    dp[位置i][位置i-1の文字は'A'か'B'か] := 最小値
  として、DPする。
    dp[i+1][使用した文字] = min(dp[i][同じ文字が連続]+1, dp[i][異なる文字が連続]);
  というようにすれば良い。
  
  解法2.
  Div1Easyに通ずるような解法があるらしい。[要追記]
  
SRM 650 Div2 Hard TheKingsRoadsDiv2
[問題]
  2^H-1個の辺を持つ2^H-1個の頂点からできる無向グラフが与えられる。
  一つの辺を抜いたとき、このグラフが高さHの完全二分木になるかどうか答えよ。
  2 <= H <= 10
  
[解答]
  例えば以下の様な条件を満たすかどうか確かめれば良い。
    1. 完全二分木において、根の次数 = 2, 葉の次数 = 1, 節点の次数 = 3 である。
    2. それぞれ頂点数が、1個、2^(H-1)個、(2^H-1)-1-2^(H-1) = 2^(H-1)-2個ずつ存在する。
    3. 完全二分木は根から再帰的に見て、各頂点を根とする部分木の子のサイズが等しい。
  抜く辺を処理を全探索し、唯一の次数2の頂点を特定する。
  その頂点からDFSを用いてサイズが対称かどうか判定すると、O(N^2)程度で解くことができる。
  
SRM 651 Div2 Easy RobotOnMoonEasy
[問題]
  グリッド状をロボットが移動する。
  ロボットは初め'S'に居る。'#'は通れず、移動しようとするとその場に留まる。場外に出たら死亡する。
  上下左右に移動するコマンド列が与えられるのでロボットの生死を判定せよ。
  
[解答]
  コマンドを1つずつシミュレートさせてやれば良い。
  
SRM 651 Div2 Med FoxAndSouvenirTheNext
[問題]
  数列A[]を2つに分割する。それぞれの和と個数が一致するような分け方は存在するか。
  1 <= |A| <= 50
  1 <= A[i] <= 50
  
[解答]
  分割の片方が和と個数それぞれ半分に分割する事ができるか調べる。以下のようなDPをすると良い。
    dp[位置i][分割の片方の要素数j][和の値k] := そのような分割は存在するか
  O(N^4)くらいで解ける。
  整数の半分であるので、数列A[]の和と要素数がそれぞれ偶数かどうかのチェックを忘れないようにする。
  
SRM 651 Div2 Hard FoxConnection4
[問題]
  '.', '#'で構成されたN*Mのグリッドがある。
  グリッド上において、互いに辺を共有しているKマスの'.'の連結成分の数をMOD10^9+9で求めよ。
  1 <= N, M <= 10
  1 <= K <= 8
  
[解答]
  まず、K個の'.'の連結成分を全パターン列挙する。
  K=8の最大ケースにおいて連結成分のパターン数は2725個なので、適当に実装しても列挙が時間内に収まる。
  次に、与えられたグリッドと列挙した連結成分のグリッドの一致を1つずつ愚直に見て、その数を数え上げればよい。
  MODを取れという問題文の指示はダミー。
  
SRM 652 Div2 Easy ValueOfString
[問題]
  val[]は次のように定義される。val['a'] = 1, val['b'] = 2, ...
  k[i]は文字列sの中にs[i]以下の値を持つ文字を含む個数(s[i]自身を含める)と定義される。
  Σ k[i] * val[s[i]] を求めよ。
  
[解答]
  mapなどで文字の数をカウントしておく。
  i番目の文字について、'a'からs[i]までのそれぞれの文字数を数える。
  val[i]と掛けあわせたものを全てのiについて足し合わせれば良い。
  
SRM 652 Div2 Med ThePermutationGameDiv2
[問題]
  p[]は1〜Nのpermutationである。p[]は1-indexedである。
  関数f: f(m) = p[f(m-1)], f(1) = p[1]
  いかなるpermutationであれ、f(m)の値が1となるような最小のmを求めよ。
  N <= 35
  
[解答]
  f(x)のxを大きく取ると、どのようなpermutaitonであっても1〜Nの周期で移動することが分かる。
  よって、1〜NまでのLCMを取れば解となる。
  
SRM 652 Div2 Hard NoRightTurnDiv2
[問題]
  平面上にN個の点が与えられる。任意の点からはじめて右に曲がらずに全ての点を結ぶパスを描けるか？
  2 <= N <= 50
  
[解答]
  開始の点を入力の点の凸包の何れかの頂点に一致させる。例えば一番左上の座標を選ぶなどとする。
  あとは出来る限り偏角を小さくした点を順に訪れていけば良い。
  
SRM 653 Div2 Easy CountryGroup
[問題]
  N人が一列に座っている。各々は自国から来た人間が何人かを宣言する。
  それぞれの国から来たの人間が必ず隣り合う人のペアで過不足なく構成される場合は、国の種類を求めよ。
  そうでない場合は-1とせよ。
  1 <= N <= 100
  1 <= A[i] <= 100
  
[解答]
  宣言された数字を満たす分だけ隣り合っているかどうか数列の左から調べる。
  新しい宣言の数字が来たら、種類数を増加させる。
  
SRM 653 Div2 Med RockPaperScissorsMagicEasy
[問題]
  相手のじゃんけんの手札がN回分与えられる。一回のじゃんけんで勝ったときに1点、そうでない時に0点が得られる。
  丁度S点取るために自分が出すことのできるN回分の手札のパターン数(MOD10^9+7)を求めよ。
  1 <= N <= 2000
  0 <= A[i] <= 2
  0 <= S <= 2000
  
[解答]
  S回勝って、N-S回負けるためのパターン数を求めれば良い。これは相手の手札の内容にかかわらず、Nに対して一定である。
  comb(N, S) * 2^(N-S) が答えとなる。Sが2000まであるので、2のべき乗の計算にpowなどを使わないで、N-S回だけ2を掛けるようにする。
  
SRM 653 Div2 Hard SingingEasy
[問題]
  曲の音のピッチがP[]で与えられる。隣接するピッチの差の分だけ歌う難しさが増加する。
  この曲をAliceとBobの2人で歌う。各々が歌った音のピッチにおいて、それぞれ歌う難しさを計算する。
  2人の歌う難しさの総和を最小化せよ。
  1 <= N <= 2000
  1 <= P[i] <= 10^6
  
[解答]
  Aliceが最後に歌った音のピッチのindexをpa, Bobが最後に歌った音のピッチのindexをpbとする。
  次にAliceまたはBobによって歌われる音のピッチのindexは next = max(pa, pb) + 1 である。
  よって、状態を(Aliceが最後に歌った音のピッチ, Bobが最後に歌った音のピッチ)としてメモ化再帰する。
  まだ歌ってない状態をpa = 0やpb = 0としておきたいので、P[]を1-indexedにしておくと、遷移は、
    dp[pa][pb] = min(dfs(next, pa) + abs(P[next] - P[pa]), dfs(pa, next) + abs(P[next] - P[pb]))
  となり、O(N^2)で解が求まる。
  
SRM 654 Div2 Easy SquareScoresDiv2
[問題]
  文字列Sが与えられる。同じ文字が連続しているSの部分文字列の数を数え上げよ。
  1 <= |S| <= 100
  
[解答]
  愚直に全探索する。二重ループで解くことができる。
  始点iに対して、j>=iについて順に調べる。文字が同じ場合カウントして、そうでない場合jのループを出て、iを増加させる。
  
SRM 654 Div2 Med OneEntrance
[問題]
  N頂点の木が与えられる。各々のノードに荷物を１つずつ置いていく。
  荷物は大きいため、既に荷物が置いてある場所を通り抜けることは出来ない。
  頂点Sが出口であり、最後にこの場所に荷物を置く必要がある。全ての頂点に荷物を置く方法は何通りか。
  1 <= N <= 9
  
[解答]
  解法1.
  問題文を言い換えると、頂点Sを木の根とみなし、木の葉を順番に消していく方法は何通りあるかとなる。
  Nが小さいので葉の消し方を全探索することができる。具体的には、消す順番ord[]を頂点Sを取り除いたpermutationで構成し、
  最後に頂点Sを消すとすればよい。そのような消しかたが可能であれば状態をカウントする。葉かどうかは次数を見ることで確認できる。
  
  解法2.
  evimaさんの解法
  DFSで上手いこと計算する[要追記]
  DFSでの計算方法はいくつかあるようだが...
  
  解法3.
  kmjpさんの解法
  ある荷物を超えて荷物を置くことが出来ないという条件により、ノードi, j間の距離をD[i][j]とすると
  新たに置く荷物y, 既に置いてある荷物x に対し、D[root][x] = D[root][y] + D[y][x]が成り立つことを利用するようだ。[要追記]
  
SRM 654 Div2 Hard SuccessiveSubtraction2
[問題]
  整数列A[]をマイナス符号でつなげた式がある。この式に最大2つの括弧を付けることができる。
  i回目のクエリP[i], V[i]によって、A[P[i]] = V[i]に変更される。
  クエリを実行するたびに式の計算結果の最大値を求めよ。
  1 <= |A|, |P| <= 2000
  |P| = |V|
  0 <= P[i] <= N-1
  -100 <= A[i], V[i] <= 100
  
[解答]
  各クエリにおいて以下のDPで最大値を求める。
    dp[i番目][a回開きカッコを使用した][b回閉じカッコを使用した] := 式の最大値
  a >= b が保たれていることを保証する必要がある。
  状態遷移は、(a, b) -> (a', b')と遷移するとすれば、a -> a' ∈ [a, 3], b -> b' ∈ [b, a'] の間で次の状態を決める。
  遷移は以下の式で更新できる。
    dp[i][nopen][nclose] = max{ dp[i-1][open][close] + a[i] * sign }
    ただし、sign = (open + close) % 2 ? +1 : -1 (初めが-1で、片括弧の数が1つ増えるor減ると、以降の計算について正負が反転する)
  max(dp[N-1][0][0], dp[N-1][1][1], dp[N-1][2][2]) で一度のクエリにおける解が求まる。
  全体でO(N*Q)で解が求まる。実際は、括弧の状態の保持のため、定数倍が少し大きくなり、
  2000(クエリ数) * 2000(数列の要素数) * 3*3(状態a, b) * 3*3(状態a', b') ≒ 3 * 10^8 程度の計算量になるが何とか間に合う。
  
SRM 655 Div2 Easy BichromeBoard
[問題]
  'W','B','?'で構成されたN*Mのグリッドがある。'?'に適切な'W','B'を充てがったとき、グリッドを市松模様にすることができるか。
  1 <= N, M <= 50
  
[解答]
  左上を'W'としたN*Mの完全な市松模様と、左上を'B'ではじめたものとを用意する。
  与えられたグリッドが、2つのグリッドの何れか一つと'?'を無視して一致すれば良い。
  
SRM 655 Div2 Med FoldingPaper2
[問題]
  W*Hのグリッドを幅高さともに整数で平行に折りたたむ。面積をちょうどAにするために最小で何回折ればよいか。
  1 <= W, H <= 10^9
  1 <= A <= 10^5
  
[解答]
  解けてません[要追記]
  
SRM 655 Div2 Hard NineEasy
[問題]
  問題文の意味が分かりません。[要追記]
  
[解答]
  
  
SRM 656 Div2 Easy CorruptedMessage
[問題]
  全て同じ文字で構成された文字列がある。そのうち丁度K個の文字が別の文字に変わっている。
  変化後の文字列Sと整数Kが与えられるので、元の文字列として適当なものを一つ求めよ。
  
[解答]
  文字数を数えて、|S|-Kに一致する文字で文字列を作る。
  |S| == Kのとき、文字列Sに含まれていない適当な文字を|S|個連結した文字列を求めれば良い。
  
SRM 656 Div2 Med RandomPancakeStackDiv2
[問題]
  N個のパンケーキがある。i(0-indexed)番目のパンケーキは幅がi+1であり、美味しさがd[i]である。
  重ねたパンケーキの美味しさは重なっている各々のパンケーキの美味しさの総和である。
  パンケーキを等確率で一つ選び、重ねていく作業をする。下の段より大きいパンケーキを選んでしまった場合はそれを重ねずに終える。
  重ねたパンケーキの美味しさの期待値を求めよ。
  1 <= N <= 10
  1 <= d[i] <= 100
  
[解答]
  N!で重ねる順番を全探索しよう。実際の重ねたパンケーキが同じでも、仮に幅を無視して最後まで重ねられるとした時の順番を区別して、
  全ての重ねたパンケーキの美味しさの総和を取る計算をする。
  「幅が１度でも重ねた最上部のパンケーキより小さくなったとき、パンケーキは選ぶものの美味しさには加えないものとする。」
  と問題文を言い換えたとも捉えることができる。
  期待値は確率による加重平均であることに注意し、それぞれの順番が等確率に発生すると考えて美味しさの和をN!で割ると期待値が求まる。
  
SRM 656 Div2 Hard PermutationCountsDiv2
[問題]
  1〜Nの順列で、殆どがA[i] > A[i+1]の関係を満たすN要素の数列A[]を考える。
  po[]に含まれる値pos[i]について、又その時に限り、A[pos[i]] < A[pos[i+1]]が成り立つ。
  Nとpos[]が与えられたとき、条件をみたすような順列A[]のパターン数を求めよ。(MOD10^9+7)
  1 <= N <= 200
  pos[]の要素は重複しない。
  
[解答]
  解法1.
  Div1 Medの制約(N <= 2500)に対応できる解法を示す。
  pos[]をソートしたとき、pos[i]とpos[i+1]との間の部分数列は、必ず連続降下列となっている。
  はじめに、この連続降下列をカタマリと見なして並び替える方法の数を考える。
  もちろんこの時点でpos[i]における昇順関係を考慮していないので「数えすぎ」であるが、ひとまず無視する。（条件を一部捨てる）
  カタマリの要素数をV[i]個とし、V[]の要素数をK=|pos|+1とすると、
  パターン数は、N! / (V[0]!*V[1]!*...V[K-1]!)
  組み合わせで考えれば、C(N, V[0]) * C(N-V[0], V[1]) * C(N-V[0]-V[1], V[2]) * ... * C(V[K-1], V[K-1])
  となる。さて、どのように「数え過ぎ」であるかというと、pos[i]で昇順関係が指定されているにもかかわらず、その位置で降順である場合も数えている。
  言い換えると、昇順関係の制約がある部分を降順に捉えた数え上げを許して計算している。つまり「禁止パターン」も数えている。
  禁止パターンの数え上げをうまく引く事のできる方法は包除原理である。
  包除原理は2のべき乗の要素の重ねあわせを試して、要素数で交互に足し引きをする方法である。
  今回、昇順関係の制約がある部分に降順関係を許したので、ここが一つのpos[i]当たりに2パターンの可能性がある。
  つまり、2^|pos|だけの重ねあわせが考えられる。2のべき乗なので、やはり包除原理で解くことが出来そうである。
  包除原理は、禁止パターンを、禁止パターンと見なせる個数を0から順に上げていくことで計算できる。
  今回の例で考えると、
  禁止パターンを0個までとみなす: 全てのカタマリの順列を考慮して計算 N! / (V[0]!*V[1]!*...V[K-1]!)
  禁止パターンを1個までとみなす: pos[i]の1個だけ取り出す。この位置は昇順関係の制約があるが、禁止である降順関係適用できると考える。これを全てのiについて計算する。
  禁止パターンを2個までとみなす: pos[i], pos[j] (i≠j) の2個だけを取り出す。この位置に禁止である降順関係を適用できると考える。これを全てのi, jについて計算する。
  ...
  となる。pos[i]の使用、不使用と考えると2のべき乗パターンあることになるが、これをDPでまとめ上げて計算する。
  今回、pos[]の要素が連続する区間をひとまとめにして、連続降下列を作ることで禁止パターンを適用すると考える。
  例として、カタマリの数の数列{a, b, c, d}を考える。
  纏め方は、{[a], [b, c], d}や、{[a, b, c], [d]}や、{a, b, [c, d]}などが考えられる。
  まとめた区間が重なることがない、つまり、{[a, [b], c], d}のようなことは起こらないので、まとめる区間を順に見ていくことができる。深さが高々1の括弧付けのパターン数と捉えても良い。
    dp[i] := iまで考慮し、最後にiを終端として区間をまとめたときの、N!/(V[0]!*V[1]!*...V[i-1]!)の分母について、カタマリの全ての重ねあわせの計算
    dp[0] = 1
    dp[i] = Σ_{0<=j<i} dp[j] * (-1)^(i-j) / (pos[i]-pos[j])!
  としてDPで包除原理が計算できる。dp[|pos|-1] * N!が解となる。上の式で(-1)^(i-j)としているが、
  実際の計算においては、(i-j)%2の値をみればよい。MOD計算の引き算はMOD-patを足すと見なすと分かりやすい。
  また、階乗と階乗の逆元がMOD10^9+7で必要なので、それらをはじめにO(N)で生成しておく必要がある。
  具体的には、階乗をMODでNまで計算した後、N!の逆元を取り、N, N-1, ...を掛けながら逆方向に計算すれば、階乗の逆元を求めることができる。
  N!の逆元はフェルマーの小定理を利用してMOD-2乗を繰り返し自乗法で計算すれば良い。
  
  無理やり言葉で説明したので、よくわからない場合は以下を参考にすると良い。
  http://kmjp.hatenablog.jp/entry/2015/04/20/1000
  http://twilog.org/meguru_comp/date-150417
  http://apps.topcoder.com/forums/?module=Thread&threadID=853127&start=0
  
SRM 657 Div2 Easy EightRooks
[問題]
  'R'または'.'で構成された8x8のグリッドがある。行と列ともに、唯一の'R'を含むかどうか判定せよ。
  
[解答]
  二重ループで各行と各列に存在する'R'の数を数えて、それが1つであるかを判定すればよい。
  
SRM 657 Div2 Med ProblemSetsEasy
[問題]
  SRMの開催にはEasy,Med,Hardの問題が1題ずつ必要である。同じ問題を二度使うことは出来ない。
  Easy用の問題がE個、Med用の問題がM個、Hard用の問題がH個ある。
  また、EasyまたはMed用の問題がEM個、MedまたはHard用の問題がMH個ある。
  開催可能なSRMの最大の回数を答えよ。
  0 <= E, M, H, EM, MH <= 10^5
  
[解答]
  X回開催できるというように、解を仮定する。
  解が成立するかどうか、判定する。
    1. EよりXが大きい場合、差分をEMから引く。EMが足りなければダメ。
    2. HよりXが大きい場合、差分をMHから引く。MHが足りなければダメ。
    3. MよりXが大きい場合、差分<=EM+MHが成り立たなければダメ。
    4. それ以外はOK。
  最後のサンプルで最大ケースが与えられていて、Xは高々166666までなので、for(X=166666; X>=0; X--)...として解を全探索すれば良い。
  なお、Div1Easyでは制約が大きいため解を二分探索することで解くことができる。
  
SRM 657 Div2 Hard PolynomialRemainder
[問題]
  a, b, c が与えられて、P(x) = a*x^2+b*x+c である。
  0<=x<10^9であり、P(x)≡0(mod 10^9)の解となるようなxは存在するか。
  存在する場合は、そのうち一つのxを求めよ。
  
[解答]
  10^9=2^9*5^9であるので、P(x)を2^9で割り切る場合とP(x)を5^9で割り切る場合との2つに分解し、それらを纏めることを考える。
  P(x)≡0(mod 2^9)が成り立つxは、xを0<=x<2^9までで全探索できる。
  P(x)≡0(mod 5^9)が成り立つxは、xを0<=x<5^9までで全探索できる。
  それぞれをCRTすると良い。[要実験]
  全探索の解法は、方法によってTLEがありよく分かってない。[要追記]
  
SRM 658 Div2 Easy InfiniteString
[問題]
  関数fは文字列Sを引数に与えると、Sを生成する最小の長さの周期の文字列を生成する。例えば、f("ababab") = "ab"である。
  文字列S, Tが与えられる。f(S) = f(T)かどうか判定せよ。
  1 <= |S|, |T| <= 50
  
[解答]
  解法1.
  下手な解法から紹介。
  最小の周期の文字列を実際に生成する。SとTについて、それらが一致しているかどうか判定する。
  周期の文字列に一文字ずつ加えていって、まだ周期的ならposを増加(mod |周期の文字列長|)
  周期的でなくなったらposを初期化して、前の初期化位置から現在位置まで一気に文字列を追加するなどとする。
  
  解法2.
  周期的であれば、公倍数長にした文字列が一致するはずである。
  よって、文字列Sを|T|回連結した文字列と、文字列Tを|S|回連結した文字列を比較すればよい。
  
  解法3.
  解法2とほぼ同じだが、連結した文字列を作らずに、S[i%mod|S|] == T[j%mod|T|] の比較を、|S|*|T|回繰り返せばよい。
  
SRM 658 Div2 Med MutaliskEasy
[問題]
  N体の敵のHPが与えられる。プレイヤーの一度の攻撃で異なる敵に異なるダメージ{9,3,1}のいずれかを1ターンにつき1度ずつ与えることができる。
  すべての敵を討伐するまでに消費するターン数を求めよ。
  1 <= N <= 3
  1 <= x[i] <= 60
  
[解答]
  与えられるダメージと敵のHPとで貪欲的にダメージを割り振る解法はうまく成立しない。[要追記]
  
  解法1.
  DPを考える。状態(0番目の敵のHP, 1番目の敵のHP, 2番目の敵のHP)とする。
  ダメージの割り当て方は全探索で良い。即ち、{1, 3, 9}の順列をnext_permutationで割り当てれば良い。
  D[]を{1, 3, 9}の順列とすると、
  dp[i-D[0]][j-D[1]][k-D[2]] = min(dp[i-D[0]][j-D[1]][k-D[2]], dp[i][j][k] + 1)
  とすれば、ターン数を最小化することができる。
  
  解法2.
  Nが小さいので全探索が可能。[kmjp解、要追記]
  
SRM 658 Div2 Hard OddEvenTreeHard
[問題]
  N頂点の木の情報がx[][]で与えられる。x[i][j] = 'E'のとき、iとjの間の道の長さは偶数であり、
  x[i][j] = 'O'のとき、道の長さは奇数であることを示す。また、x[i][j] = '?'のとき、偶奇は不明である。
  x[][]の情報が本当に正しい木に基づく情報であるかどうかを判定し、正しい情報であれば生成される木を一つ求めよ。
  
[解答]
  考察中...
  
  x[i][j] = odd, x[j][k] = odd のとき、x[i][j] = evenである必要がある、みたいな条件から、
  4通りのodd,evenの道の条件ができる。
  あと、各iが孤立点で無く全て連結していることを保証するために、少なくとも1つのjについて、x[i][j] = 'O'となるような道（この場合は辺？）が必要。
  木となるかどうかの判定がこれらの条件だけでいいのかどうか、判定はよく分かってませんが、とりあえずこれでサンプルの間違った情報は弾けます。
  
  その次が少し面倒そうで、多分、適当な頂点から奇数パスを選んでいって、DFSしたときに偶奇の矛盾なく全ての頂点を網羅できるか調べるのかなと思っていますが、まだ実装すらしてません。

SRM 674 Div2 Med BearPlaysDiv2
[問題]
  3つの数字から異なる2つの数字を選ぶ。小さい方をX, 大きい方をY とおき、nextX = 2*X nextY -= X と変換する。
  この操作を繰り返して、すべての数字を揃えることが出来るか？
  1 <= A, B, C <= 500

[解答]
  2つの数字が決まれば、もう1つの数字は合計-(2つの数字の和)できまるので、状態数は500*500で済む。
  よって、メモ化再帰で問題文通りに実装すればよい。
  A, B, C の小さい2つの数字を map<pair<int, int>, bool> memo や、int memo[1501][1501] (-1: unused) などで記憶する。

SRM 676 Div2 Med BoardEscapeDiv2
[問題]
  '.','#','E','T'で構成されたN*Mのグリッドがある。
    '.'はempty
    '#'はwall
    'T'はただひとつ存在するスタート地点
    'E'は出口
  'T'にある駒を2人が交互に動かす。2人合わせて最大K回動かしたとき、自分の手番で動かせない方が負けである。
  'E'に駒を置いた場合、相手は動かすことが出来ない。K+1回以上動かすことは出来ない。
  1 <= N, M <= 50
  1 <= K <= 100

[解答]
  解法1
  状態数が50*50*100なので、2人交互にゲームする再帰をメモすることで解ける。
  
  解法2
  先手が1度だけ動いて'E'にたどり着けるなら、先手の勝ち。
  そうでないなら、後手が1回動くときにどうやっても

SRM 677 Div2 Easy PalindromePrime
[問題]
  正の整数L, Rに対して、[L,R]に含まれる数のうち、素数でありかつ文字列と見なしたときに回文となる数を求めよ。
  1 <= L, R <= 1000
  
[解答]
  [L,R]のすべての数について、素数判定、回文判定をそれぞれ愚直に行う。O(N^2)で解くことが出来る。

SRM 677 Div2 Med FourStrings
[問題]
  文字列a, b, c, dが含まれる文字列Sのうち、最小の長さを求めよ。
  |a|, |b|, |c|, |d| <= 10

[解答]
  解法1.
  一文字ずつ使う文字を決めてメモ化再帰する。
  状態は(文字列のサイズ, aの位置i, bの位置j, cの位置k, dの位置l)
  遷移は ni = 0 or (a[i] == usech ? i+1 : 0) とする。使う文字と一致していても無視して0に行くパターンがあることを忘れない。
  使う文字を26文字ではなく、a, b, c, dに含まれる文字のみ使用するとすれば、テストケースを通過させることが出来る。
  ただし、計算量が見積もりにくい上、条件が一部抜けていてもサンプルが通ってしまうので、推奨される解法ではない。
  
  解法2.
  a, b, c, dの順列のpa, pb, pc, pdを各々のsuffixとprefixが重なるようにつなげたときの最小の長さを求めればよい。
  AOJでも同様の問題でこれより簡単な厳しい制約の問題が少なくとも2つある。同じと気づくためには、上の一文のように問題を少し変形させる必要がある。
  
SRM 677 Div2 Hard PalindromePath
[問題]
  辺{a[i], b[i]}で、bidirectionalなグラフが与えられる。各々の辺にはアルファベット1文字が与えられている。
  辺を移動するときに現在の状態へ文字を加えていき、文字列を生成する。
  頂点0から頂点1へ移動したときにできている文字列が回文となるように移動したとき、その回文の最小の長さを求めよ。
  N <= 20
  #(a[]), #(b[]) <= N * (N + 1) / 2
  
[解答]
  解法1.
  回文は前から見てi番目と後ろからみてi番目が同じ文字であるので、双方向のBFSを行えば良い。
  頂点0からと頂点1からとで、同じ文字を持つ辺を辿るという条件でBFSする。
  頂点0から頂点1に到達した時に回文判定したり、別々に頂点0からあらゆるパスによる文字列を生成するBFSと頂点1も同様のBFSをして、
  その結果を比較するようなコードはTLEしてしまう。回文の条件を活かすためには、文字列を持ってBFSせずに遷移条件に前後の文字の一致を使う。
  
  解法2.
  最小の回文の長さを1から前後に1文字ずつ伸ばしていくDPをする。
  頂点kから頂点lまでのパスで最小の回文の長さをdp[i][j]とおく。
  dp[k][l] = min(dp[k][l], dp[i][j] + 2) if edge[i][k] == edge[j][l]
  初期条件は、dp[a[i]][b[i]] = 1 for all i
  
SRM 679 Div2 Easy ListeningSongs
[問題]
  各曲の長さA[], B[]であり、M分の制限時間内にできるだけ多くの曲を聴く。
  そのうちT曲はA[]からもB[]からも選ぶ必要がある。
  聴くことの出来る最大の曲数を答えよ。
  1 <= N, M, T <= 100
  
[解答]
  M = M * 60 とする。
  A[], B[]をソートし、両方の初めからT曲だけとってそれらの和がM以内か調べる。
  残り時間内で、A[]\初めのT曲, B[]\初めのT曲 をマージしたC[]をソートしたものからできるだけ多くの曲を聴く。
  
SRM 679 Div2 Med ContestScoreboard
[問題]
  スコアボードが以下の形式で与えられる。コンテストの時間が1〜10^9の任意の時間であるとき、i番目の人が優勝することが出来るか？
  {"name_0, s_0/t_0", ..., "name_i s_i/t_i", ...}
  s_i は 得点
  t_i は 提出時間。コンテストの時間内にstrictlyに収まるならvalidとなる。
  得点がタイなら、名前が辞書順で小さいものが高い順位となる。
  
[解答]
  まず、元の名前と番号の対応関係を保持する。
  名前の辞書順にするため、[string]の入力をそのままソートする。
  次に、入力をパースする。stringstreamを使えば、ss >> si >> dummy >> ti; という感じに書けるので楽。
  Dの候補として、1と全てのt_i+1を試す。
  各々のDにおいて合計点をソートすれば、一番順位の高い人の元のindexは優勝可能とわかる。

SRM 679 Div2 Hard ForbiddenStreets
[問題]
  重み付き無向グラフが与えられる。
  それぞれの辺について、その辺を通行禁止にしたときに、元のグラフと比較して最短距離が変わってしまうような2点(unordered pair)の総数を数え上げよ。
  
[解答]
  辺e = {a, b} がsrc->destの最短経路上に無くてはならない辺である
  <=> src->destの最短距離 = src->aの最短距離 + 辺a<->bの重み + b->destの最短距離
      かつ src->dest の最短経路パターン数 = src->a の最短経路パターン数 * b->dest の最短経路パターン数
  
  これを利用して解く。各頂点からダイクストラして、任意頂点間における最短経路のパターン数を求める。
  このとき、最短経路が巨大になるのでMODをとることになるが、恣意的なテストケースにやられないように、複数の巨大なMOD値を選ぶ必要がある。
  実際、10^9+7, 10^9+9, 10^9+21 のどれか一つでは、サンプルでは全て通るもののシステムテストでは全て落ちる。
  そのため、例えばこれらのうち2つ以上のMOD値を選んで、各々についてパターン数を計算すればよい。
  
SRM 685 Div2 Easy MultiplicationTable2Easy
[問題]
  数列の添字に対して二項演算子$を定義する。
  数列T[]に対して、i$jは、要素N*Nの配列S[]を2次元配列とみなして、S[T[i]*N+T[j]]を参照することを意味する。
  全てのi, jについて、S[T[i]*N+T[j]]がT[]に含まれるかどうか判定せよ。
  
[解答]
  問題文が少し読みづらいかもしれないが、読むことが出来れば題意の通りの判定をすればよい。
  例えば、任意の(i, j)、含まれているかの判定kの3重ループで解けば良い。
  
SRM 685 Div2 Med DoubleWeights
[問題]
  無向グラフが与えられる。
  weight1[i][j]は、{i, j}間のノードが1つ目のコストweight1[i][j]を持つことを示す。
  weight2[i][j]は、{i, j}間のノードが2つ目のコストweight2[i][j]を持つことを示す。
  今、ノード0からノード1まで移動しようとしている。このとき、総コストは、W1*W2で計算される。
  W1とは、経路上のweight1[i][j]の総和であり、W2とは経路上のweight2[i][j]の総和である。
  W1*W2を最小化せよ。また、経路が存在しない場合は-1とせよ。
  2 <= N <= 20
  
[解答]
  パスの総コストの積を最小化することに注意する。
  想定される誤解法としては、今まで通ってきた辺のweight1[][]の和とweight2[][]の和の2量を従属に状態のコストとして、ダイクストラする方法である。
  例えば、積を状態のコストとしていた場合、あるノードについて(w1, w2) = (20, 20) に対して、(w1, w2) = (100, 3) の方が小さいと見なしてしまったため、
  続きのパスでw2が上昇して、w1が大きいがために最終的の積が大きくなってしまう、などが考えられる。
  [この辺り要確認。2量のコストを持ってダイクストラしている解法もあるため]
  
  同じ経路を通りつつ、しかしW1とW2を独立的に計算したい。
  例えば片方のW1のパターンを事前に網羅できないか考える。
  しかし、コストのパターンを網羅するということは、下手な方法では最悪の場合初めのノード0と最後のノード1以外の高々18個について、順列の18!パターンを考慮することになる。
  パターンが網羅できないのであれば、片方を固定した値としてもう片方のコストを動かして最短経路計算が出来ないかを考える。
  例えばW2を固定する。すると、ダイクストラの状態として、weight1[][]の総和を最小化することのみ考慮すれば良くなる。
  weight2[][]の総和は高々W2までとする。それに対して、weight2[][]の総和もダイクストラの状態として持つが、これは、W2を超えないように拡張グラフを張るという制約のために持つものである。
  weights2[][]の総和がW２以内に収まり、ノード1に到達したら、Σweight1[][] * Σweight2[][]　を計算し、最小化する。
  W2は二分探索でダイクストラとは別に最小化することで解が求まる。
  
SRM 685 Div2 Hard RGBTree
[問題]
  無向グラフが与えられる。各辺にはR, G, Bの何れかの色が塗られている。
  このグラフから全域木を作ったとき、Rの辺の数 = Gの数 = Bの辺の数 が成り立つような木を作れるか。
  4 <= N <= 13
  N mod 3 = 1
  
[解答]
  状態(使用した頂点mask, Rの辺の数, Gの辺の数, Bの辺の数) としてメモ化再帰する。
  Bの辺の数は特別RとGの数の補数になるようなことはないので、これも忘れずに状態に含める。
  頂点数が最大13個なので、全域木の辺の数は最大12本。各々の色の辺の数は最大4本となる。
  全域木なので、全頂点を使用するまで再帰することとなる。
  各々辺の数の状態を0本から4本までの5つまで記憶する必要がある。計算量は 2^13 * 5^3 ≒ 10^6 程度。
  
  